1.	FE List keyword
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_LIST_KEYWORD
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/FE_LIST_KEYWORD.
  TYPES: BEGIN OF ty_result,
           keyword TYPE string,
           count TYPE i,
         END OF ty_result.

  DATA: lv_enh_name2 TYPE char256,
        lv_enh_name TYPE ENHNAME,
        itab TYPE string_table,
        lt_badi_table TYPE STANDARD TABLE OF enhsort,
        ls_badi TYPE REF TO enhsort,
        in_text TYPE string,
        itab1 TYPE STANDARD TABLE OF SSTMNT,
        itab2 TYPE STANDARD TABLE OF STOKESX,
        rtab2 TYPE REF TO STOKESX,
        lt_key TYPE STANDARD TABLE OF DOKIL,
        lr_key TYPE REF TO DOKIL,
        lt_token TYPE string_table,
        lt_result TYPE STANDARD TABLE OF ty_result,
        ls_result TYPE ty_result,
        lv_count TYPE i,
        ls_source TYPE string.

  SELECT ENHNAME FROM enhsort INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME LIKE '/SFA%' AND version = 'A'.

  check sy-subrc = 0.

  LOOP AT lt_badi_table REFERENCE INTO ls_badi.

     CLEAR: itab1,itab2.
     lv_enh_name = ls_badi->enhname.
     CONCATENATE 'Handling' lv_enh_name '...' INTO in_text SEPARATED BY space.
     CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = in_text.
     TRANSLATE lv_enh_name USING ' ='.
     CONCATENATE lv_enh_name 'EIMP' INTO lv_enh_name2.
     READ REPORT lv_enh_name2 INTO itab.
     SCAN ABAP-SOURCE itab TOKENS INTO itab2 STATEMENTS INTO itab1 WITH ANALYSIS.
     LOOP AT itab2 REFERENCE INTO rtab2.
        APPEND rtab2->str TO lt_token.
     ENDLOOP.
  ENDLOOP.

  SORT lt_token.

  LOOP AT lt_token INTO in_text.
     lv_count = lv_count + 1.
     AT END OF table_line.
        ls_result-keyword = in_text.
        ls_result-count = lv_count.
        APPEND ls_result TO lt_result.
        CLEAR: lv_count.
     ENDAT.

  ENDLOOP.

  DELETE lt_result WHERE ( keyword CS '/' OR keyword CS '''' OR keyword CS '<' OR keyword CS '>' OR keyword CS '('
    OR keyword CS ')' OR keyword CS '-' OR keyword CS '_' OR keyword CS '=' OR keyword CS '&' OR keyword CS '*' OR keyword CS '+' ).
  DELETE lt_result WHERE keyword CA '0123456789'.

  DATA: gr_alv TYPE REF TO cl_salv_table,
        column_table TYPE REF TO CL_SALV_COLUMNS_TABLE,
        column TYPE REF TO CL_SALV_COLUMN,
        gr_selections TYPE REF TO cl_salv_selections.

CALL METHOD cl_salv_table=>factory
      IMPORTING
        r_salv_table   = gr_alv
      CHANGING
        t_table        = lt_result.

DATA: gr_layout TYPE REF TO cl_salv_layout.
DATA: key TYPE salv_s_layout_key.

gr_layout = gr_ALV->get_layout( ).
key-report = sy-repid.
gr_layout->set_key( key ).

gr_layout->set_save_restriction( if_salv_c_layout=>restrict_none ).

DATA: gr_functions TYPE REF TO CL_SALV_FUNCTIONS_LIST.
gr_functions = gr_ALV->get_functions( ).
      gr_functions->set_all( abap_true ).



gr_selections = gr_alv->get_selections( ).
gr_selections->set_selection_mode( 1 ). "Single

  column_table = gr_alv->GET_COLUMNS( ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'KEYWORD' ).
  column->SET_MEDIUM_TEXT( 'ABAP KEYWORD' ). "#EC NOTEXT

  column->SET_OPTIMIZED( exporting value = 'X' ).
  "column->SET_OUTPUT_LENGTH( exporting value = 20 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'COUNT' ).
  column->SET_MEDIUM_TEXT( 'Occurance' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).


  CALL METHOD gr_alv->display.
2. Manual data flow
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_MANUAL_DATAFLOW
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/FE_MANUAL_DATAFLOW.
DATA: lt_result TYPE /SF0A0001/TT_MANUAL_DATA_FLOW,
      lt_temp TYPE /SF0A0001/TT_MANUAL_DATA_FLOW,
      RFCDEST like rfcdes-rfcdest.

DO 2 TIMES.
   CASE sy-index.
      WHEN 1.
        RFCDEST = 'S8G'.
      WHEN 2.
        RFCDEST = 'S8L'.
   ENDCASE.

   CLEAR: lt_temp.

   CALL FUNCTION 'ZFE_GET_MANUAL_DATAFLOW' DESTINATION rfcdest
     IMPORTING
        out_data = lt_temp.

   CHECK lt_temp IS NOT INITIAL.
   APPEND LINES OF lt_temp TO lt_result.
ENDDO.

SORT lt_result BY DATA_FLOW_ENH DATA_FLOW EEW_EXTENSIONID.

DELETE ADJACENT DUPLICATES FROM lt_result COMPARING DATA_FLOW_ENH DATA_FLOW EEW_EXTENSIONID.

DATA:   gr_alv TYPE REF TO cl_salv_table,
        column_table TYPE REF TO CL_SALV_COLUMNS_TABLE,
        column TYPE REF TO CL_SALV_COLUMN,
        gr_selections TYPE REF TO cl_salv_selections.

CALL METHOD cl_salv_table=>factory
      IMPORTING
        r_salv_table   = gr_alv
      CHANGING
        t_table        = lt_result.

DATA: gr_layout TYPE REF TO cl_salv_layout.
DATA: key TYPE salv_s_layout_key.

gr_layout = gr_ALV->get_layout( ).
key-report = sy-repid.
gr_layout->set_key( key ).

gr_layout->set_save_restriction( if_salv_c_layout=>restrict_none ).

DATA: gr_functions TYPE REF TO CL_SALV_FUNCTIONS_LIST.
gr_functions = gr_ALV->get_functions( ).
      gr_functions->set_all( abap_true ).



gr_selections = gr_alv->get_selections( ).
gr_selections->set_selection_mode( 1 ). "Single

  column_table = gr_alv->GET_COLUMNS( ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'DATA_FLOW_ENH' ).
  column->SET_MEDIUM_TEXT( 'Dataflow Enhancement' ). "#EC NOTEXT

  column->SET_OPTIMIZED( exporting value = 'X' ).
  "column->SET_OUTPUT_LENGTH( exporting value = 20 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'DATA_FLOW' ).
  column->SET_MEDIUM_TEXT( 'Dataflow Name' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  "\column->SET_OUTPUT_LENGTH( exporting value = 20 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'EEW_EXTENSIONID' ).
  column->SET_MEDIUM_TEXT( 'EEW Extension ID' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  "column->SET_OUTPUT_LENGTH( exporting value = 20 ).

  CALL METHOD gr_alv->display.
3. Display BO left size and extensibility
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_UPPER_LMT_CAL
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/FE_UPPER_LMT_CAL.
include /SF0A0001/FE_UPPER_LMT_CAL_h.
include /SF0A0001/GET_SHARED_DB_TAB_h.
include /SF0A0001/FE_UPPER_LMT_CAL_s.
include /SF0A0001/FE_UPPER_LMT_CAL_f.
include /SF0A0001/CL_UTIL.



*&---------------------------------------------------------------------*
*&       Class /SF0A0001/LCL_UTIL
*&---------------------------------------------------------------------*
*        Text
*----------------------------------------------------------------------*


start-of-selection.

if p_leftby = abap_true.
* get BO Nodes to respective BO
  lv_business_object = p_bo.
  try.
      call method /ext/cl_model_adapter=>get_bo_nodes
        exporting
          i_bo_name   = p_bo
        importing
          et_bo_nodes = lt_bo_nodes
        changing
          ct_messages = lt_messages.
    catch /ext/cx_base into lx_previous.
        message 'BO entered does not exist.' type 'E' display like 'I'.
  endtry.

*Filter extensible BO Nodes and add proxy_node_datatype info and extension include name info
  loop at lt_bo_nodes into ls_bo_node where is_extensible = abap_true.
    clear ls_node_entry .
    ls_node_entry-bo_name        = ls_bo_node-prx_bo_name.
    ls_node_entry-node_name      = ls_bo_node-prx_nd_name.
    ls_node_entry-prx_dt_name    = ls_bo_node-prx_nd_attr_dtype.

    try.
        ls_ext_include =
          cl_eew_extensionregistry=>get_prxdtype_extinclude( iv_prx_dtype_name = ls_node_entry-prx_dt_name ).
        ls_node_entry-ext_include_name  = ls_ext_include.
      catch cx_eew_registry into lx_previous.
    endtry.

* For given node(respective Ext Include Name) calculate available space and number of fields
"    ls_field_size_include =
"           cl_eew_extensionregistry=>get_size_enhanced_fields( iv_ext_incl = ls_ext_include-eew_extincname ).

** Hi Jerry - in the calculation above I missed to ad the quota for customer field in respect to further SAP fields/Partner fields
** I aded the correction Corrected calculation of available space - could you please repace the following two lines with the subsequent commented two lines?

*    ls_node_entry-number_of_bytes_left  = ls_ext_include-eew_max_bytes   - ls_field_size_include-bytes_fields.
*    ls_node_entry-number_of_fields_left = ls_ext_include-eew_max_fields  - ls_field_size_include-nr_fields.
**   Determine available space for additional extension fields
    ls_node_entry-number_of_fields_left = ( ls_ext_include-eew_max_fields * ls_ext_include-eew_perc_cust / 100 ) - ls_field_size_include-nr_fields.
    ls_node_entry-number_of_bytes_left  = ( ls_ext_include-eew_max_bytes * ls_ext_include-eew_perc_cust / 100 ) - ls_field_size_include-bytes_fields.

    perform isextensionpossible.

    if ls_node_entry-number_of_bytes_left - size_extension >= 0 and ls_node_entry-number_of_fields_left - number_extension >= 0.
    ls_node_entry-is_extensible = abap_true.
    endif.

    append ls_node_entry to lt_node_entries.
 endloop.

*Display result in ALV Popup (downloadable to EXCEL)
  /SF0A0001/LCL_UTIL=>show_alv_table_left(
      it_result_entries   =  lt_node_entries
      iv_bo_name          =  lv_business_object ).

endif.

if p_share = abap_true.
select * from /SF0A0001/NODELT into table it_shared where bo_name = p_bo2
                                                        and node_name = p_bonode.

  /SF0A0001/LCL_UTIL=>show_alv_table_shared(
      it_result_entries   =  it_shared ).
endif.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/FE_UPPER_LMT_CAL_H
*&---------------------------------------------------------------------*
type-pools: abap.
tables:/SF0A0001/NODELT.
types:
  begin of ty_gs_node_entry,
    bo_name                type scoolbusinessobject,
    node_name              type scol_business_object_node,
    prx_dt_name           type typename,
    ext_include_name      type eewdt_extension_include,
    number_of_bytes_left  type i,
    number_of_fields_left type i,
    is_extensible  type abap_bool,
  end of ty_gs_node_entry.

types ty_gt_node_entry type table of ty_gs_node_entry.
data it_shared type standard table of /SF0A0001/NODELT.

data ls_field_size_include    type cl_eew_extensionregistry=>ty_s_size_enhanced_fields.
data ls_field_size_include_db type cl_eew_extensionregistry=>ty_s_size_enhanced_fields.
data lx_previous              type ref to cx_root.

data lt_bo_nodes              type /ext/api_bo_nodes_t.
data lt_extensible_bo_nodes   type /ext/api_bo_nodes_t.
data ls_bo_node               type /ext/api_bo_node.
data lt_messages              type bapiret2_t  .
data lv_business_object       type scoolbusinessobject.

data ls_node_entry            type ty_gs_node_entry.
data lt_node_entries          type table of ty_gs_node_entry.
data ls_ext_include           type eewst_datatype_registry.
data size_extension           type i.
data number_extension         type i.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/GET_SHARED_DB_TAB_H
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*


type-pools abap.

types:
  begin of ty_gs_bo_info,
    bo_name          type scoolbusinessobject,
    node_name        type sesf_business_object_node,
    proxy_structure type typename,
  end of ty_gs_bo_info.

types:
  ty_gt_bo_infos type table of ty_gs_bo_info with default key .

types:
  begin of ty_gs_rgincl_entry,
    prx_dtype_name           type eewdt_extensible_prx_data_type,
    eew_extincname           type eewdt_extension_include,
    bo_name                   type scoolbusinessobject,
    node_name                 type sesf_business_object_node,
    transparent_table_name   type ddobjname,
  end of ty_gs_rgincl_entry.

types:
  ty_gt_rgincl_entries type table of ty_gs_rgincl_entry .

types:
    begin of ty_gs_nodes_with_shared_table,
      bo_name                   type scoolbusinessobject,
      node_name                 type sesf_business_object_node,
      transparent_table_name   type ddobjname,
      sharing_bo_name           type scoolbusinessobject,
      sharing_node_name         type sesf_business_object_node,
    end of  ty_gs_nodes_with_shared_table.

types:
  ty_gt_nodes_with_shared_table type table of ty_gs_nodes_with_shared_table with default key .

data index type i.


data ls_rgincl_entry         type ty_gs_rgincl_entry.
data ls_rgincl_entry_compare type ty_gs_rgincl_entry.
data lt_rgincl_entry         type ty_gt_rgincl_entries.
data lt_dep_tab              type eewrwg_prop_dep_tables_tt.
data ls_dep_tab              type eewrwg_prop_dep_tables.

data lt_scol_bo_node_tmp     type table of ty_gs_bo_info. "scol_bo_node.
data ls_scol_bo_node_tmp     type  ty_gs_bo_info.

data lt_scol_bo_node_tmp2    type  table of ty_gs_bo_info.
data ls_scol_bo_node_tmp2    type ty_gs_bo_info.

data ls_result_entry         type ty_gs_nodes_with_shared_table.
data lt_result_entries       type ty_gt_nodes_with_shared_table.

data lt_business_object_names type sesf_string_tab.
data lv_proxy_structure_name type string.
data ls_business_object_names type string.
data lo_bo_descriptor         type ref to if_esf_bo_desc.
data lt_bo_node_descriptor    type if_esf_bo_node_desc=>ty_descriptor_table.
data lv_bo_name               type sesf_business_object.
data lv_bo_node_name          type sesf_business_object_node.

data lx_root                type ref to cx_root.

field-symbols <lo_bo_node_descriptor>    type ref to if_esf_bo_node_desc.
field-symbols <it_line> like line of lt_result_entries.
data my_data like /SF0A0001/NODELT.

parameters P_Run AS CHECKBOX.
selection-screen comment /1(83) text-001.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_UPPER_LMT_CAL_S
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*


parameters     p_leftby     radiobutton group opt.
parameters p_bo type scoolbusinessobject
  obligatory  default  '/EXT/EXTENSIBILITY_TEST' matchcode object zz_businessobject. "/EXT/WB_BUSINESSOBJECT.

parameters p_dec type i default 0.
parameters p_date type i default 0.
parameters p_time type i default 0.
parameters p_check type i default 0.
parameters p_amount type i default 0.
parameters p_quanti type i default 0.
parameters p_vhelp type i default 0.
parameters p_stext type i default 0.
parameters p_mtext type i default 0.
parameters p_ltext type i default 0.
parameters p_xltext type i default 0.
parameters: p_table type i default 0,
 p_tablen type i default 0.
selection-screen skip.

parameters     p_share     radiobutton group opt.
parameters p_bo2 type scoolbusinessobject
  obligatory  default  '/EXT/EXTENSIBILITY_TEST' matchcode object zz_businessobject. "/EXT/WB_BUSINESSOBJECT.
parameters p_bonode type string obligatory default 'Root'.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_UPPER_LMT_CAL_F
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*


form isextensionpossible.
    size_extension = p_dec * 16 + p_date * 16 + p_time * 12 + p_check * 2 + p_amount * 22 + p_quanti * 22 + p_vhelp * 10 +
    p_stext * 20 + p_mtext * 80 + p_ltext * 160 +  p_xltext * 510 + p_table * p_tablen.
    number_extension = p_dec  + p_date  + p_time  + p_check  + p_amount  + p_quanti  + p_vhelp +
    p_stext + p_mtext  + p_ltext +  p_xltext  + p_table .

  endform.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_UPPER_LMT_CAL_F
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*


form isextensionpossible.
    size_extension = p_dec * 16 + p_date * 16 + p_time * 12 + p_check * 2 + p_amount * 22 + p_quanti * 22 + p_vhelp * 10 +
    p_stext * 20 + p_mtext * 80 + p_ltext * 160 +  p_xltext * 510 + p_table * p_tablen.
    number_extension = p_dec  + p_date  + p_time  + p_check  + p_amount  + p_quanti  + p_vhelp +
    p_stext + p_mtext  + p_ltext +  p_xltext  + p_table .

  endform.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/CL_UTIL
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/FE_UPPER_LMT_CAL_C
*&---------------------------------------------------------------------*
class /SF0A0001/LCL_UTIL definition.

  public section.
    class-methods convert_to_short_txt
        importing
          iv_short_text type csequence
        returning
          value(rv_converted_short_text)  type scrtext_s .

    class-methods convert_to_medium_txt
        importing
          iv_medium_text type csequence
        returning
          value(rv_converted_medium_text)  type scrtext_m .

    class-methods convert_to_long_txt
        importing
          iv_long_text type csequence
        returning
          value(rv_converted_long_text)  type scrtext_l .

    class-methods show_alv_table_left
        importing
          it_result_entries type  ty_gt_node_entry
          iv_bo_name           type  scoolbusinessobject.

    class-methods show_alv_table_shared
        importing
          it_result_entries type table
         .
    class-methods show_alv_table
        importing
          it_result_entries type ty_gt_nodes_with_shared_table.
endclass.               "/SF0A0001/LCL_UTIL


*----------------------------------------------------------------------*
*       CLASS /SF0A0001/LCL_Util IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
class /SF0A0001/LCL_Util implementation.
  method convert_to_short_txt.
    rv_converted_short_text  = iv_short_text.
  endmethod. "convert_to_short_txt

  method convert_to_medium_txt.
    rv_converted_medium_text  = iv_medium_text.
  endmethod.                    "convert_to_medium_txt

  method convert_to_long_txt.
    rv_converted_long_text  = iv_long_text.
  endmethod.                    "convert_to_long_txt



  method  show_alv_table_left.

    data lo_alv_table type ref to cl_salv_table.

    data lo_columns               type ref to  cl_salv_columns_table.
    data lo_column                type ref to cl_salv_column.
    data lv_column_name           type lvc_fname.

    data lx_exception             type ref to  cx_salv_not_found.

    data lv_header_text           type lvc_title.

    data lt_result_entries        type  ty_gt_node_entry.

    lt_result_entries = it_result_entries.

    try.
* Create ALV Instance
        call method cl_salv_table=>factory
          importing
            r_salv_table = lo_alv_table
          changing
            t_table      = lt_result_entries.

        lo_alv_table->get_functions( )->set_all( abap_true ).

* Set Title
        concatenate text-001 iv_bo_name into lv_header_text respecting blanks.
        lo_alv_table->get_display_settings( )->set_list_header( lv_header_text ). "Extension Field Quotas for BO ...'

* Configure layout for individual columns
        try.
            lo_columns    = lo_alv_table->get_columns( ).



*    ext_include_name      TYPE EEWDT_EXTENSION_INCLUDE,
*    number_of_bytes_left  TYPE i,
*    number_of_fields_left TYPE i,

* Bo Name
            lv_column_name = 'BO_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ).
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* Node Name
            lv_column_name = 'NODE_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ).
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* Proxy Name
            lv_column_name = 'PRX_DT_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_visible( abap_false ).

* Proxy Name
            lv_column_name = 'EXT_INCLUDE_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_visible( abap_false ).
*
* number_of_bytes_left
            lv_column_name = 'NUMBER_OF_BYTES_LEFT'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ).
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* number_of_fields_left
            lv_column_name = 'NUMBER_OF_FIELDS_LEFT'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ).
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* ExtensibleIndicator
            lv_column_name = 'IS_EXTENSIBLE'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ).
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

          catch cx_salv_not_found into lx_exception."one of the columns could not be found

        endtry.
*Set length of column so that all entries are shown completely
        lo_columns->set_optimize( ).

* Display Table as modal pop up
        lo_alv_table->display( ).

      catch cx_salv_msg  .
*show error pop up
*Creation of ALV Table failed to display check results failed!
*      MESSAGE ID '/EXT/UI_CHK_AND_REP'  TYPE 'I' NUMBER 006.
    endtry.
  endmethod.                    "show_alv_table_left

 method  show_alv_table_shared.
    data lo_alv_table type ref to cl_salv_table.

    data lo_columns               type ref to  cl_salv_columns_table.
    data lo_column                type ref to cl_salv_column.
    data lv_column_name           type lvc_fname.

    data lx_exception             type ref to  cx_salv_not_found.


    try.
* Create ALV Instance
        call method cl_salv_table=>factory
          importing
            r_salv_table = lo_alv_table
          changing
            t_table      = it_shared.

        lo_alv_table->get_functions( )->set_all( abap_true ).

* Set Title
        lo_alv_table->get_display_settings( )->set_list_header( 'Persistent table sharing report result:' ). "Persistent table sharing report result:'

* Configure layout for individual columns
        try.
            lo_columns    = lo_alv_table->get_columns( ).

* transparent_table_name

            lv_column_name = 'TRANSPARENT_TABL'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Table Name
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* sharing_bo_name
            lv_column_name = 'SHARING_BO_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Sharing BO
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* sharing_node_name
            lv_column_name = 'SHARING_NODE_NAM'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Sharing Node
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

          catch cx_salv_not_found into lx_exception."one of the columns could not be found

        endtry.
*Set length of column so that all entries are shown completely
        lo_columns->set_optimize( ).

* Display Table as modal pop up
        lo_alv_table->display( ).

      catch cx_salv_msg  .
*show error pop up
*Creation of ALV Table failed to display check results failed!
*      MESSAGE ID '/EXT/UI_CHK_AND_REP'  TYPE 'I' NUMBER 006.
    endtry.
  endmethod.                    "show_alv_table



  method  show_alv_table .
    data lo_alv_table type ref to cl_salv_table.

    data lo_columns               type ref to  cl_salv_columns_table.
    data lo_column                type ref to cl_salv_column.
    data lv_column_name           type lvc_fname.

    data lx_exception             type ref to  cx_salv_not_found.


    try.
* Create ALV Instance
        call method cl_salv_table=>factory
          importing
            r_salv_table = lo_alv_table
          changing
            t_table      = lt_result_entries.

        lo_alv_table->get_functions( )->set_all( abap_true ).

* Set Title
        lo_alv_table->get_display_settings( )->set_list_header('Persistent table sharing report result:'). "Persistent table sharing report result:'

* Configure layout for individual columns
        try.
            lo_columns    = lo_alv_table->get_columns( ).

* transparent_table_name

            lv_column_name = 'TRANSPARENT_TABLE_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Table Name
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* sharing_bo_name
            lv_column_name = 'SHARING_BO_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Sharing BO
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

* sharing_node_name
            lv_column_name = 'SHARING_NODE_NAME'.
            lo_column    = lo_columns->get_column( lv_column_name ).
            lo_column->set_short_text( /SF0A0001/LCL_Util=>convert_to_short_txt( lv_column_name ) ). "Sharing Node
            lo_column->set_medium_text( /SF0A0001/LCL_Util=>convert_to_medium_txt( lv_column_name ) ).
            lo_column->set_long_text( /SF0A0001/LCL_Util=>convert_to_long_txt( lv_column_name ) ).

          catch cx_salv_not_found into lx_exception."one of the columns could not be found

        endtry.
*Set length of column so that all entries are shown completely
        lo_columns->set_optimize( ).

* Display Table as modal pop up
        lo_alv_table->display( ).

      catch cx_salv_msg  .
*show error pop up
*Creation of ALV Table failed to display check results failed!
*      MESSAGE ID '/EXT/UI_CHK_AND_REP'  TYPE 'I' NUMBER 006.
    endtry.
  endmethod.                    "show_alv_table
endclass.               "/SF0A0001/LCL_Util
3. FSI View check
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FE_VIEW_CHECK
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/FE_VIEW_CHECK.

PARAMETERS: bo TYPE sfsg_qr_bo_query_id-bo_model OBLIGATORY DEFAULT 'APCI_CUST_INV_REQUEST',
            node TYPE sfsg_qr_bo_query_id-bo_node OBLIGATORY DEFAULT 'OVERVIEW',
            query TYPE sfsg_qr_bo_query_id-bo_query OBLIGATORY DEFAULT 'QUERY_BY_ELEMENTS'.

DATA:   l_id             TYPE sfsg_qr_bo_query_id,
        lr_repository    TYPE REF TO if_gfs_query_repository,
        lx_sfs_exception TYPE REF TO cx_sfs_not_found,
        wrong TYPE string,
        m_querydef TYPE REF TO SFSG_QUERY_DEF_RT,
        result TYPE SFSG_QB_RESULT_MAPPING_T,
        result_line LIKE LINE OF result,
        m_qe TYPE REF TO CL_FSI_GENERIC_QE,
        lt_messages TYPE CM_ESI_ROOT=>TT_ESI_ROOT,
        ls_line LIKE LINE OF lt_messages,
        lr_runtime TYPE REF TO IF_FSI_VIEW_RT_PROXY.

  l_id-bo_model = bo.
  l_id-bo_node  = node.
  l_id-bo_query = wrong = query.

  lr_repository = cl_gfs_query_repository=>get_instance( ).

  TRY.
      m_querydef = lr_repository->load_rt( l_id ).

    CATCH cx_sfs_not_found INTO lx_sfs_exception.

     WRITE:/ 'Cannot find Query for: ', query.
     RETURN.

  ENDTRY.

  IF m_querydef IS INITIAL.
     WRITE:/ 'Cannot find Meta data for query:' , query.
     RETURN.
  ENDIF.

  WRITE:/ 'View Name:' , m_querydef->VIEW_NAME.

  WRITE:/ 'Mapping class Name:' , m_querydef->SEL_MAP_PRV.

  NEW-LINE.

  WRITE:/ 'Result Mapping'.

  LOOP AT m_querydef->RESULT_MAPPINGS INTO result_line.
    WRITE:/ 'Bo Node field:' , result_line-BO_NODE_FIELD.
    WRITE:/ 'View field Name:', result_line-view_field_name.
    NEW-LINE.
    SKIP 1.
  ENDLOOP.

  "CL_FSI_QUERY_PREPROCESSOR~CONVERT
  CREATE OBJECT m_qe.
  m_qe->init(
      in_viewname = m_querydef->VIEW_NAME ).

  cl_gfs_replication_status=>get_view_load_status( EXPORTING in_view_name = m_querydef->VIEW_NAME
                                                             in_target    = m_qe->ms_engine
                                                   IMPORTING out_messages = lt_messages ).

  IF lt_messages IS NOT INITIAL.
     LOOP AT lt_messages INTO ls_line.

     ENDLOOP.
     ASSERT 1 = 0.
  ENDIF.

  lr_runtime = m_qe->get_runtime_proxy( ).
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/FSI_VIEW
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/FSI_VIEW.


PARAMETERS: view TYPE SFSG_DEFINITION_NAME OBLIGATORY DEFAULT 'PRODUCT_FSI_OWL_CO'.
 DATA lv_view       TYPE sfsg_definition_name.
  DATA lv_view_field TYPE fieldname.
  DATA lo_view_repos TYPE REF TO if_fsi_view_repository.
  DATA lo_view       TYPE REF TO if_fsi_view.
  DATA lt_vext_names TYPE sfsg_definition_key_t.
  DATA lt_view_flds  TYPE sfsg_view_fields_t.
  DATA lv_view_ext   TYPE sfsg_definition_name.
  DATA lv_message    TYPE string.
  DATA view_field_count TYPE i.
  DATA ls_bo_proxy TYPE SCOL_BO_NODE.
  DATA lv_view_name TYPE SFSG_DEFINITION_NAME.
  DATA line_index TYPE i.
  DATA ls_proxy TYPE /EXT/L_EXT_PRXDT.
  DATA lt_run TYPE SFSG_DEFINITION_KEY_T.
  DATA fieldname TYPE string.
  DATA RT_BO_NODES TYPE SFSG_BO_NODES_T.
  DATA lo_view_ext   TYPE REF TO if_fsi_view_ext.

  FIELD-SYMBOLS <local_view_extension> TYPE sfsg_def_d.
  FIELD-SYMBOLS <ls_vext_name> TYPE sfsg_def_key.
  FIELD-SYMBOLS <local_view_field> TYPE LINE OF sfsg_view_fields_t.
  FIELD-SYMBOLS <local_extended_view>.

  lv_view = view.
  lo_view_repos = cl_fsi_view_repository=>get_instance( ).
  TRY.
      lo_view = lo_view_repos->get_view(
        i_view_name = lv_view
        I_AS4LOCAL = 'A'
        ).
    CATCH cx_sfs_not_found.

  ENDTRY.

  WRITE:/ 'FSI View Name:' , lv_view.

if lo_view is not initial.
  lt_vext_names = lo_view->get_extension_names( ).

  LOOP AT lt_vext_names ASSIGNING <ls_vext_name>.
    WRITE: / 'Extension View Name:', <ls_vext_name>-DEF_NAME.
    TRY.
        lo_view_ext = lo_view_repos->get_extension(
          i_extension = <ls_vext_name>-def_name
          i_as4local  = <ls_vext_name>-as4local
          ).
      CATCH cx_sfs_not_found cx_gfs_origin_not_found.
        CONTINUE.
    ENDTRY.

    lt_view_flds = lo_view_ext->if_fsi_view~get_view_fields( ).

    LOOP AT lt_view_flds ASSIGNING <local_view_field>.
       WRITE:/ 'View Field Name:' , <local_view_field>-view_field_name.

       SELECT SINGLE * INTO ls_proxy FROM /EXT/L_EXT_PRXDT WHERE PRX_FIELD = <local_view_field>-bo_node_attribute.
       CHECK sy-subrc = 0.
       SELECT SINGLE * INTO ls_bo_proxy FROM SCOL_BO_NODE WHERE DATA_STRUCTURE = ls_proxy-PRX_DATA_TYPE.

       CHECK sy-subrc = 0.
       WRITE:/ 'BO Name:' , ls_bo_proxy-bo_name.
       WRITE:/ 'BO Node Name' , ls_bo_proxy-node_name.


*    CALL METHOD lo_view_ext->IF_FSI_VIEW~GET_EXTENSION_NAMES
*      RECEIVING
*         RT_EXT_DEFS = lt_run.
*
*    CALL METHOD lo_view_ext->GET_EXTENSION_OF_ID
*      RECEIVING
*         rs_view_name = lv_view_name.
*
*    CALL METHOD lo_view_ext->IF_FSI_VIEW~GET_BO_NODES
*      RECEIVING
*         RT_BO_NODES = RT_BO_NODES.
  ENDLOOP.
 ENDLOOP.
ENDIF.
4. ABAP name ->ESR name
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/GET_ABAP_BY_ESR
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/GET_ABAP_BY_ESR.

SELECTION-SCREEN BEGIN OF BLOCK part1 WITH FRAME TITLE text-001.
PARAMETERS: abap RADIOBUTTON GROUP rad1,
            esr RADIOBUTTON GROUP rad1 DEFAULT 'X',
            name TYPE string LOWER CASE OBLIGATORY DEFAULT 'ProductionBillofMaterialEnhancedController',
            spa TYPE string LOWER CASE DEFAULT 'http://sap.com/xi/A1S'.
SELECTION-SCREEN END OF BLOCK part1.

DATA: ECO TYPE string VALUE 'http://sap.com/xi/A1S'.

AT SELECTION-SCREEN.
   IF esr = 'X' AND spa IS INITIAL.
      MESSAGE 'You must input BO''''s Namespace!' TYPE 'E' DISPLAY LIKE 'E'.
      RETURN.
   ENDIF.

START-OF-SELECTION.

  DATA: lp_lcp           TYPE REF TO if_esf_lcp,
        lp_lcp_facade    TYPE REF TO if_esf_lcp_facade,
        lp_bo_descr TYPE REF TO if_esf_bo_desc.

  DATA: ls_esr_name TYPE sesf_md_esr_name.

  DATA: lf_bo_name      TYPE string,
        bo_proxy_name   TYPE string,
        lf_bo_node_name TYPE string.

  lp_lcp_facade = cl_esf_lcp_factory=>get_lcp_facade( ).

  IF esr = 'X'.
  TRY.
    CALL METHOD lp_lcp_facade->get_bo_descriptor
      EXPORTING
        in_bo_esr_name      = name
        in_bo_esr_namespace = spa
      RECEIVING
        out_bo_descriptor   = lp_bo_descr.

    bo_proxy_name = lp_bo_descr->if_esf_desc~get_proxy_name( ).
    WRITE:/ 'ESR Name:', name.
    WRITE:/ 'BO Proxy Name:', bo_proxy_name.
    CATCH cx_esf_core_service .
      WRITE:/ 'Invalid ESR Name for BO:', name.
      RETURN.
  ENDTRY.

  ELSE.
     TRY.
     lp_bo_descr = lp_lcp_facade->get_bo_descriptor( in_bo_proxy_name = name ).
     CATCH cx_esf_core_service .
      WRITE:/ 'Invalid Proxy Name for BO:', name.
      RETURN.
  ENDTRY.
     ls_esr_name = lp_bo_descr->get_esr_name( ).
     lf_bo_name = ls_esr_name-esr_namespace.
     lf_bo_node_name = ls_esr_name-esr_name.
     WRITE:/ 'ESR name:', lf_bo_node_name.
     WRITE:/ 'ESR namespace:', lf_bo_name.
     WRITE:/ 'BO Proxy name:', name.
  ENDIF.
5. manually delete extension field
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/MANUAL_DELETE_EXTEND
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/MANUAL_DELETE_EXTEND.
DATA: field_name TYPE /EXT/S_UI_FIELDDETAILS-PRX_FIELDNAME VALUE '/SF0A001B/F08TCTESTBYJERRY',
      TR TYPE TRKORR VALUE 'S8FK000630',
      ID TYPE char32 VALUE '/SF0A001B/08TES8F20100525080036',
      lx_error TYPE REF TO /ext/cx_extension,
      lv_text TYPE string.

DATA: lo TYPE REF TO /EXT/CL_EXTENSION.

TRY.
lo ?= /EXT/CL_EXTENSION_FACTORY=>get_instance( ID ).
CATCH /EXT/CX_EXTENSION INTO lx_error.
   lv_text = lx_error->get_text( ).
   MESSAGE lv_text TYPE 'I' DISPLAY LIKE 'E'.
   RETURN.
ENDTRY.
TRY.
      lo->/EXT/IF_EXTENSION~DELETE( TR ). "-- S8FK000630

    CATCH /ext/cx_extension INTO lx_error.
      lv_text = lx_error->get_text( ).
      IF lv_text IS NOT INITIAL.
        MESSAGE lv_text TYPE 'I' DISPLAY LIKE 'E'.
      ENDIF.

  ENDTRY.

  WRITE:/ 'OK'.
6. Update ESR Software component version
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/UPDATE_ESR_SWCV
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/UPDATE_ESR_SWCV.
TYPE-POOLS abap.

PARAMETERS package  TYPE devclass OBLIGATORY.
PARAMETERS request  TYPE trkorr.
PARAMETERS simulate TYPE abap_bool AS CHECKBOX DEFAULT abap_true.

DATA lv_message                 TYPE string.
DATA lv_extension_id            TYPE eew_extension_id.
DATA ls_extension               TYPE /ext/if_metadata_access=>ty_gs_extension.
DATA lt_extension_ids           TYPE eew_ts_extension_id.
DATA lt_updated_extensions      TYPE eew_ts_extension_id.
DATA lt_unchanged_extensions    TYPE eew_ts_extension_id.
DATA lt_inconsistent_extensions TYPE eew_ts_extension_id.
DATA ls_package                 TYPE tdevc.
DATA ls_software_component      TYPE /ext/sld_swc_attr.
DATA lt_software_components     TYPE /ext/sld_swc_attr_t.
DATA lo_extension_repository    TYPE REF TO /ext/if_enh_repository_access.
DATA lx_previous                TYPE REF TO /ext/cx_base.

AT SELECTION-SCREEN.
* Check input
  IF request IS INITIAL and simulate = abap_false.
    lv_message = 'Enter a request'.
    MESSAGE lv_message TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
* Get extension repository access instance
  lo_extension_repository = /ext/cl_enh_repository_access=>get_instance( ).

* Get extensions in given package
  lt_extension_ids = lo_extension_repository->get_ids_by_package( package ).

  IF lt_extension_ids IS INITIAL.
    lv_message = 'Package' && package && 'does not contain any extensions'.
    MESSAGE lv_message TYPE 'E'.
    RETURN.
  ENDIF.

* Get package properties (including ABAP software component assignment)
  CALL FUNCTION 'TR_DEVCLASS_GET'
    EXPORTING
      iv_devclass        = package
    IMPORTING
      es_tdevc           = ls_package
    EXCEPTIONS
      devclass_not_found = 1
      OTHERS             = 2.

  IF sy-subrc <> 0.
    lv_message = 'Package' && package && 'does not exist'.
    MESSAGE lv_message TYPE 'E'.
    RETURN.
  ENDIF.

* Get locally installed ESR software components
  TRY.
      lt_software_components = /ext/cl_esr_adapter=>create_instance( )->get_local_software_components( ).

    CATCH /ext/cx_esr_adapter INTO lx_previous.
      lv_message = 'Could not retrieve locally installed software component versions'.
      MESSAGE lv_message TYPE 'E'.
      RETURN.
  ENDTRY.

* Get properties of ESR software component which corresponds to the package's ABAP software component
  READ TABLE lt_software_components INTO ls_software_component
    WITH KEY swcname = ls_package-dlvunit.

  IF sy-subrc <> 0.
    lv_message = 'Could not find software component which is assigned to given package'.
    MESSAGE lv_message TYPE 'E'.
    RETURN.
  ENDIF.

* Update ESR software component UUID if necessary
  LOOP AT lt_extension_ids INTO lv_extension_id.
*   Get extension properties (including ESR software component UUID assignment)
    TRY.
        lo_extension_repository->get(
          EXPORTING
            iv_extension_id = lv_extension_id
          IMPORTING
            es_extension    = ls_extension ).

        IF ls_extension IS INITIAL.
          INSERT lv_extension_id INTO TABLE lt_inconsistent_extensions.
          CONTINUE.
        ENDIF.

      CATCH /ext/cx_enh_repository_read INTO lx_previous.
        INSERT lv_extension_id INTO TABLE lt_inconsistent_extensions.
        CONTINUE.
    ENDTRY.

*   Update ESR software component UUID in repository
    IF ls_extension-esr_swcv_uuid <> ls_software_component-swcv_guid.
      IF simulate = abap_false.
        TRY.
            lo_extension_repository->update_software_component_uuid(
              iv_extension_id            = lv_extension_id
              iv_software_component_uuid = ls_software_component-swcv_guid
              iv_package                 = package
              iv_request                 = request ).
            COMMIT WORK.
          CATCH /ext/cx_enh_repository_access INTO lx_previous.
            ROLLBACK WORK.
            lv_message = 'Software component update failed for extension' && lv_extension_id.
            MESSAGE lv_message TYPE 'E'.
            RETURN.
        ENDTRY.
      ENDIF.
*     Notify extension update
      INSERT lv_extension_id INTO TABLE lt_updated_extensions.
    ELSE.
*     Notify that extension is already up-to-date
      INSERT lv_extension_id INTO TABLE lt_unchanged_extensions.
    ENDIF.
  ENDLOOP.

* Notify changes
  LOOP AT lt_updated_extensions INTO lv_extension_id.
    WRITE: / 'Updated extension', lv_extension_id, 'succcessfully'.
  ENDLOOP.
  LOOP AT lt_unchanged_extensions INTO lv_extension_id.
    WRITE: / 'Extension', lv_extension_id, 'was already up-to-date'.
  ENDLOOP.
  LOOP AT lt_inconsistent_extensions INTO lv_extension_id.
    WRITE: / 'Extension', lv_extension_id, 'is inconsistent'.
  ENDLOOP.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/UPGRADE_SOFTWARECOM
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/UPGRADE_SOFTWARECOM.
include /sf0a0001/UPGRADE_SWC_h.
include /sf0a0001/UPGRADE_SWC_s.



at selection-screen.
* Check input
  if request is initial and simulate = abap_false.
    lv_message = 'Enter a request'.
    message lv_message type 'E'.
  endif.

start-of-selection.
* Get extension repository access instance
  lo_extension_repository = cl_eew_extension=>get_instance( ).

* Get all extensions
  lt_extensions = lo_extension_repository->get_all( ).

* Extract active extensions of the given package
  delete lt_extensions
    where as4local <> 'A' or devclass <> package.

  if lt_extensions is initial.
* Indicate that given package does not contain any extensions
    lv_message = 'Package' && package && 'does not contain any extensions'.
    message lv_message type 'E'.
    return.
  endif.

* Get ABAP software component of package
  call function 'TR_DEVCLASS_GET'
    exporting
      iv_devclass        = package
    importing
      es_tdevc           = ls_package
    exceptions
      devclass_not_found = 1
      others             = 2.

  if sy-subrc <> 0.
    lv_message = 'Package' && package && 'does not exist'.
    message lv_message type 'E'.
    return.
  endif.

* Get locally installed ESR software components
  try.
      lt_software_components = /ext/cl_esr_adapter=>CREATE_instance( )->get_local_software_components( ).

    catch /ext/cx_esr_adapter.
      lv_message = 'Could not determine locally installed software components'.
      message lv_message type 'E'.
      return.
  endtry.

  SORT lt_software_components.
* Get properties of ESR software component which corresponds to the package's software component
  read table lt_software_components into ls_software_component
    with key swcname = ls_package-dlvunit.

  if sy-subrc <> 0.
    lv_message = 'Could not find ESR software component' && ls_package-dlvunit.
    message lv_message type 'E'.
    return.
  endif.

* Classify extensions according to the need for updating the software component
  loop at lt_extensions into ls_extension.
    if ls_extension-swcv_guid <> ls_software_component-swcv_guid.
      ls_extension-swcv_guid = ls_software_component-swcv_guid.
      insert ls_extension into table lt_extensions_update.
    else.
      insert ls_extension into table lt_extensions_unchanged.
    endif.
  endloop.

* Update software component in repository
  if simulate = abap_false.
    loop at lt_extensions_update into ls_extension.
      try.
          lo_extension_repository->save(
            is_extension          = ls_extension
            iv_package            = package
            iv_request            = request ).
          lo_extension_repository->activate( ls_extension-eew_extensionid ).
          commit work.
        catch cx_eew_extension.
          rollback work.
          lv_message = 'Could not update repository data of extension' && ls_extension-eew_extensionid.
          message lv_message type 'E'.
          return.
      endtry.
    endloop.
  endif.

* Notify changes
  loop at lt_extensions_update into ls_extension.
    write: / 'Updated extension', ls_extension-eew_extensionid, 'with software component', ls_software_component-swcv_guid.
  endloop.
  loop at lt_extensions_unchanged into ls_extension.
    write: / 'Extension', ls_extension-eew_extensionid, 'was already up-to-date'.
  endloop.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/UPGRADE_SWC_H
*&---------------------------------------------------------------------*
data lv_message              type string.
data ls_software_component   type /ext/sld_swc_attr.
data lt_software_components  type /ext/sld_swc_attr_t.
data ls_package              type tdevc.
data ls_extension            type eewdb_eewext.
data lt_extensions           type if_eew_extension=>ty_gts_extension_header.
data lt_extensions_unchanged type if_eew_extension=>ty_gts_extension_header.
data lt_extensions_update    type if_eew_extension=>ty_gts_extension_header.
data lo_extension_repository type ref to if_eew_extension.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/UPGRADE_SWC_S
*&---------------------------------------------------------------------*
parameters package  type devclass obligatory.
parameters request  type trkorr.
parameters simulate type abap_bool as checkbox default abap_true.
7. Add extension field value help text
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/UPLOADTXTTOVALUEHELP
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/UPLOADTXTTOVALUEHELP.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_h.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_S.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_F.

************************************************************************************
************************************************************************************
* main program
************************************************************************************
************************************************************************************
at selection-screen on value-request for i_file.
  call function 'GUI_FILE_LOAD_DIALOG'
    importing
      fullpath = i_file.
end-of-selection.


start-of-selection.
  if i_file is initial.
    write: 'For extraction please specify file name to load the data'.
  endif.

  concatenate v_table '_T' into  v_table_t.

  if clear = abap_true.  " Clear Funtion
    perform clear_table .
    write:/ 'Table ' color col_normal , v_table color col_key ,  ' has be cleared.' color col_normal.

  elseif check = abap_true. " Check Funtion
    perform check_valueset.

  elseif display = abap_true. " Display Funtion
    perform display_value .

  else.
    perform process_valueset.  " Insert & Append Funtion

  endif.
*&---------------------------------------------------------------------*
*& Report  /SF0A0001/UPLOADTXTTOVALUEHELP
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  /SF0A0001/UPLOADTXTTOVALUEHELP.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_h.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_S.
INCLUDE /SF0A0001/UPLOADTXTTOVALUE_F.

************************************************************************************
************************************************************************************
* main program
************************************************************************************
************************************************************************************
at selection-screen on value-request for i_file.
  call function 'GUI_FILE_LOAD_DIALOG'
    importing
      fullpath = i_file.
end-of-selection.


start-of-selection.
  if i_file is initial.
    write: 'For extraction please specify file name to load the data'.
  endif.

  concatenate v_table '_T' into  v_table_t.

  if clear = abap_true.  " Clear Funtion
    perform clear_table .
    write:/ 'Table ' color col_normal , v_table color col_key ,  ' has be cleared.' color col_normal.

  elseif check = abap_true. " Check Funtion
    perform check_valueset.

  elseif display = abap_true. " Display Funtion
    perform display_value .

  else.
    perform process_valueset.  " Insert & Append Funtion

  endif.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/UPLOADTXTTOVALUE_H
*&---------------------------------------------------------------------*
types:   abap_bool type c length 1,
         errotype  type i .

*&---------------------------------------------------------------------*
*&      Define Variable
*&---------------------------------------------------------------------*
constants:
  abap_true      type abap_bool value 'X',
  abap_false     type abap_bool value ' ',

*& erro type
  erro_file                 type i value 1,
  erro_table_name           type i value 2,
  erro_table_operation      type i value 3,

  erro_check_quantity         type i value -1,
  erro_check_correct          type i value 0.


data: v_table_t type string .  "the text table
*DATA: prestr2(2), prestr3(3), prestr4(4) TYPE C.
data: prestr2(2), prestr3(3), prestr4(4), prestr8(8) type c.
data: base_number type i value 0 . "EXSISTING ACCOUNT OF THE RECORD

field-symbols <prestr> type c.


*&---------------------------------------------------------------------*
*&      Define struct
*&---------------------------------------------------------------------*
data: begin of it_datatab occurs 0,
    row(700) type c,
end of it_datatab.

data: begin of it_wa   occurs 0,
    code_value(30)  type c,
end of it_wa.

data: begin of it_wa_t occurs 0,
    code_value(30)     type c,
    language           type lang,
    description(160)   type c,
end of it_wa_t.

data: begin of it_wa_com occurs 0,
    code_value(30)     type c,
    language           type lang,
    description_t(160)   type c,
    description_f(160)   type c,
end of it_wa_com.

data: begin of it_wa_out occurs 0,
    row(160) type c,
    code_value(30)     type c,
    description(160)   type c,
end of it_wa_out.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/UPLOADTXTTOVALUE_S
*&---------------------------------------------------------------------*
selection-screen begin of block part1 with frame title text-001.
parameters: insert      radiobutton group  tac,
            append      radiobutton group  tac,
            clear       radiobutton group  tac,
            check       radiobutton group  tac,
            display     radiobutton group  tac.
selection-screen end of block part1.

selection-screen skip.

selection-screen begin of block part2 with frame title text-002.
parameters i_file  type  string default   'C:\Documents and Settings\i046636\Desktop\dropdownlist' .
parameters v_table type  string default   '/SFA0001C/TT' obligatory .
*PARAMETERS Lan  type  SPRAS.
parameters language type spras default  sy-langu obligatory.
selection-screen end of block part2.
*&---------------------------------------------------------------------*
*&  Include           /SF0A0001/UPLOADTXTTOVALUE_F
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&  Include           /SF0A0007/UPLOADTXTTOVALUE_F
*&---------------------------------------------------------------------*


*&---------------------------------------------------------------------*
*&      Form  PROCESS_VALUESET
*&---------------------------------------------------------------------*
form process_valueset.
  data  number  type i  value 0.

  if insert = abap_true.

    perform clear_table .

  elseif append = abap_true.
    try .
        select count(*) from (v_table_t) into base_number where language = language.

      catch cx_sy_dynamic_osql_semantics.
        perform erro_handle using erro_table_name.

    endtry.
    number = base_number.

  endif.

  perform  upload_valueset.  "Get the value from local file
  perform  set_prestr.       "Set the prefix

  loop at it_datatab.
"    NUMBER = NUMBER + 1 .
"    UNPACK NUMBER to  <PRESTR>.
"    <PRESTR> = search

    data: lv_pos type i,
          lv_len type i.

    search it_datatab-row for ';'.
    lv_pos = sy-fdpos.
    <prestr> = it_datatab-row+0(lv_pos).
    it_wa-code_value   = <prestr> .
    it_wa_t-code_value = <prestr> .

    lv_pos = lv_pos + 1.
    it_wa_t-language   = language .  " Modified for multi-language
    lv_len = strlen( it_datatab-row ).
    it_wa_t-description = it_datatab-row+lv_pos(lv_len) .

    try .
        insert into  (v_table)    values it_wa.
        insert into  (v_table_t)  values it_wa_t.

        if sy-subrc <> 0.
          perform  erro_handle using erro_table_operation.
        endif.

      catch cx_sy_dynamic_osql_semantics.
        perform erro_handle using erro_table_name.

    endtry.

  endloop.

  write:/ number, ' Dropdown list value inserted to table' color col_key ,  v_table color col_key.
  write:/ '-------------------------------------------------------------------------'.

  perform display_value .

endform.

*&---------------------------------------------------------------------*
*&      Form  CHECK_VALUESET
*&---------------------------------------------------------------------*
form check_valueset.
*  WRITE:/ 'TBD, this function is under unit test and bug fix, will be work later'.
  data  number  type i  value 0.
  data  error_num type i value erro_check_correct.
  data  datasource_quantity type i.
  data  table_quantity  like datasource_quantity .
  data  wa like it_wa_com.
  data  result_ds  type string.
  data  detail_ds  type string.

  perform  upload_valueset.



  try . " get the number of the dropdownlist in the table
     select count(*) from  (v_table_t) into table_quantity where language = language .

    catch cx_sy_dynamic_osql_semantics.

      perform erro_handle using erro_table_name.

  endtry.

  data  itab_t  like it_wa_t occurs 4000.
  try. " get the data from database
    select  * into  corresponding fields of it_wa_t
                from  (v_table_t) where language = language
                order by code_value ascending  .

      append it_wa_t  to itab_t.
    endselect.

    catch cx_sy_dynamic_osql_semantics.
      perform erro_handle using erro_table_name.

  endtry.

  describe table it_datatab lines datasource_quantity.



  if datasource_quantity ne table_quantity .  " the number is not equal
    error_num = erro_check_quantity .
    write:/ 'The dropdownlist value from file:  ',  i_file color col_normal.
    write:/ 'is', 'not consistent' color col_negative, 'with the values from Table: ', v_table  color col_normal.
    stop.
  else. " check the description

    perform  set_prestr.       "Set the prefix
    data  non_consistent_tab like it_wa_com occurs 2000.

    loop at it_datatab.

      number = number + 1 .
      unpack number to  <prestr>.

      read table itab_t into it_wa_t index number.
      if  it_wa_t-description ne it_datatab-row.

        it_wa_com-code_value  = <prestr>.
        it_wa_com-description_t = it_wa_t-description.
        it_wa_com-description_f = it_datatab-row.
        append it_wa_com to non_consistent_tab .
        error_num = error_num + 1.

      endif.

    endloop.

  endif.


*  The result display

  case error_num.
    when erro_check_quantity.
      result_ds = 'Not Consistent'.
      detail_ds = 'Even the quantity of the row is not equal'.
    when erro_check_correct.
      result_ds = 'Consistent'.
      detail_ds = 'The quantity and the content are both consistent'.
    when others.
      result_ds = 'Not Consistent'.
      detail_ds = 'The content of the related row is not consistent, the non-consistent row are:'.
  endcase.

  write:/ 'Check Result:          ' color col_key, result_ds  color col_negative , '       Language: ',  language.
  write:/ 'Table : ', v_table  color col_normal.
  write:/ 'File  :  ',  i_file color col_normal.

  write:/ '--------------------------------------------------------------------------'.
  skip 1.

  write:/ 'Detail: ', detail_ds.

  if error_num > 0.
    skip 1.
    write:/ 'CODE_VALUE' color col_key, '     ' ,'VALUE FROM TABLE'  color col_key.
    write:/ '          ',               '     ' ,'VALUE FROM FILE' color col_normal.

    loop at non_consistent_tab into it_wa_com.
        write:/ it_wa_com-code_value(10) color col_key  centered  , '     ' , it_wa_com-description_t(160).
        write:/ '          ',  '     ' ,it_wa_com-description_f(160) color col_normal .
      endloop.
  endif.



endform.

*&---------------------------------------------------------------------*
*&      Form  UPLOAD_VALUESET
*&---------------------------------------------------------------------*
form upload_valueset.
  call function 'GUI_UPLOAD'
  exporting
   filename = i_file
*   filetype = 'ASC'
   tables
   data_tab = it_datatab "ITBL_IN_RECORD[]
   exceptions
     file_open_error = 1
   others = 2.

  if sy-subrc <> 0.
    perform  erro_handle using erro_file.
  endif.

endform.

*&---------------------------------------------------------------------*
*&      Form  CLEAR_TABLE
*&---------------------------------------------------------------------*
form clear_table.

  try .
      delete from (v_table).
      delete from (v_table_t).

    catch cx_sy_dynamic_osql_semantics.
      perform erro_handle using erro_table_name.
  endtry.

endform.


*&---------------------------------------------------------------------*
*&      Form  DISPLAY VALUE
*&---------------------------------------------------------------------*
form display_value.
  data  number type i value 0 .


  if display = abap_true.
    try.
        select count(*) into number from (v_table_t).
      catch cx_sy_dynamic_osql_semantics.
        perform erro_handle using erro_table_name.
    endtry.

    write:/ 'TABLE: ', v_table color col_key .
    write: '      ',  number , 'Hits' .
    write:/ '-------------------------------------------------------------------------'.
    skip 1.
  endif.


  try.
      select  * into  corresponding fields of it_wa_t
                from  (v_table_t)
                order by language code_value ascending  .

        if sy-subrc = 0.
          write:/   it_wa_t-code_value(8)    color col_key  centered .
          write:   it_wa_t-language color col_heading.
          write:   it_wa_t-description color col_normal .
        else.
          write:/ 'The DISPLAY_VALUE' .
          perform  erro_handle using erro_table_operation.
        endif.

      endselect.

    catch cx_sy_dynamic_osql_semantics.
      perform erro_handle using erro_table_name.
  endtry.

endform.

*&---------------------------------------------------------------------*
*&      Form  SET_PRESTR    set the prefix for code_value
*&---------------------------------------------------------------------*
form set_prestr .
"  DATA  LEN  TYPE I VALUE 1.
"  DATA  COUNT TYPE I.

"  DESCRIBE TABLE it_datatab LINES count.

"  COUNT = COUNT + BASE_NUMBER.
"  WHILE COUNT > 10.
"    COUNT = COUNT / 10 .
"    len = len + 1 .
"  ENDWHILE.

 " CASE LEN .
    "WHEN 1.
      "ASSIGN prestr2 TO <PRESTR>.
    "WHEN 2.
      "ASSIGN prestr2 TO <PRESTR>.
    "WHEN 3.
      "ASSIGN prestr3 TO <PRESTR>.
    "WHEN 4.
      "ASSIGN prestr4 TO <PRESTR>.
    "WHEN OTHERS.
  "ENDCASE.

  assign prestr8 to <prestr>.

endform.


*&---------------------------------------------------------------------*
*&      Form  ERRO_HANDLE    Handle the defined erro
*&---------------------------------------------------------------------*
form erro_handle using erro_no type errotype .

  case erro_no.

    when erro_file.
      write:/ 'The Dropdown List file'  color  col_negative .
      write: i_file color col_normal.
      write: 'can not be open, please check the file or path!' color  col_negative .

    when  erro_table_name.
      write:/ 'The table' color col_normal , v_table color col_key , ' you fill in is not correct, please check!' color  col_negative .

      write:/ '1. The table may not exist;' color col_normal,
            / '2. The table may not be actived;' color col_normal,
            / '3. The table type may not consistent with the dropdown list table.' color col_normal.

    when  erro_table_operation.
      write:/ 'Erro when operate(SELECT, INSERT, UPDATE, DELETE) the table: ' color  col_negative, v_table  color col_key.

    when others.

  endcase.

  stop.
endform.
FUNCTION /SF0A0001/FE_GET_ALV_OUTPUT.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  EXPORTING
*"     VALUE(LT_VIEW_EXTENSIONS) TYPE  /SF0A0001/SFSG_DEF_D_T
*"     VALUE(LT_VIEW_FIELDS) TYPE  /SF0A0001/VIEW_FIELDS_TT
*"----------------------------------------------------------------------

FIELD-SYMBOLS <view_extension> TYPE sfsg_def_d.
DATA createdbyeew_l TYPE abap_bool.

DATA:
BEGIN OF tl_extended_views OCCURS 0,
        fsiviewextended LIKE sfsg_def_d-extension_of,
END OF tl_extended_views.
DATA it_extended_views LIKE SORTED TABLE OF tl_extended_views WITH UNIQUE KEY fsiviewextended WITH HEADER LINE.


SELECT * FROM sfsg_def_d INTO TABLE LT_VIEW_EXTENSIONS WHERE def_name LIKE '%SFA_____%'.

CHECK sy-subrc = 0.

LOOP AT lt_view_extensions ASSIGNING <view_extension>.
    PERFORM eewfsiextensioncheck_eewdb USING <view_extension>-def_name
                                         CHANGING createdbyeew_l.
      IF createdbyeew_l = abap_true.
        DELETE lt_view_extensions INDEX sy-tabix.
      ENDIF.
ENDLOOP.

SORT lt_view_extensions BY extension_of ASCENDING.
  LOOP AT lt_view_extensions ASSIGNING <view_extension>.
    READ TABLE it_extended_views WITH KEY fsiviewextended = <view_extension>-extension_of.
    IF sy-subrc <> 0.
      tl_extended_views-fsiviewextended = <view_extension>-extension_of.
      APPEND tl_extended_views TO it_extended_views.
    ENDIF.
  ENDLOOP.

"&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
  DATA lv_view       TYPE sfsg_definition_name.
  DATA lv_view_field TYPE fieldname.
  DATA lo_view_repos TYPE REF TO if_fsi_view_repository.
  DATA lo_view       TYPE REF TO if_fsi_view.
  DATA lt_vext_names TYPE sfsg_definition_key_t.
  DATA lo_view_ext   TYPE REF TO if_fsi_view_ext.
  DATA lt_view_flds  TYPE sfsg_view_fields_t.
  DATA lv_view_ext   TYPE sfsg_definition_name.
  DATA lv_message    TYPE string.
  DATA view_field_count TYPE i.
  DATA line_index TYPE i.
  DATA fieldname TYPE string.

  FIELD-SYMBOLS <local_view_extension> TYPE sfsg_def_d.
  FIELD-SYMBOLS <ls_vext_name> TYPE sfsg_def_key.
  FIELD-SYMBOLS <local_view_field> TYPE LINE OF sfsg_view_fields_t.
  FIELD-SYMBOLS <local_extended_view> LIKE LINE OF it_extended_views.



  LOOP AT it_extended_views ASSIGNING <local_extended_view>.
    PERFORM append_view_fields USING <local_extended_view>-fsiviewextended CHANGING createdbyeew_l lt_view_fields.

  ENDLOOP.

  LOOP AT lt_view_extensions ASSIGNING <local_view_extension>.
    line_index = sy-tabix.
    READ TABLE lt_view_fields WITH KEY def_name = <local_view_extension>-def_name TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      DELETE lt_view_extensions INDEX line_index.
    ENDIF.

  ENDLOOP.

ENDFUNCTION.

FORM eewfsiextensioncheck_eewdb USING ve_name TYPE sfsg_definition_name
                          CHANGING createdbyeew_l.

  DATA: ls_entry TYPE /EXT/C_ENH_OBJ.
  select single * from /EXT/C_ENH_OBJ INTO ls_entry WHERE Name = ve_name.


  IF sy-subrc = 0.
    createdbyeew_l = abap_true.

  ELSE.
    createdbyeew_l = abap_false.
  ENDIF.

ENDFORM.

FORM append_view_fields USING extended_view LIKE sfsg_def_d-extension_of  CHANGING createdbyeew_l lt_view_fields TYPE /SF0A0001/VIEW_FIELDS_TT.
  DATA lv_view       TYPE sfsg_definition_name.
  DATA lv_view_field TYPE fieldname.
  DATA lo_view_repos TYPE REF TO if_fsi_view_repository.
  DATA lo_view       TYPE REF TO if_fsi_view.
  DATA lt_vext_names TYPE sfsg_definition_key_t.
  DATA lt_view_flds  TYPE sfsg_view_fields_t.
  DATA lv_view_ext   TYPE sfsg_definition_name.
  DATA lv_message    TYPE string.
  DATA view_field_count TYPE i.
  DATA line_index TYPE i.
  DATA fieldname TYPE string.
  DATA lo_view_ext   TYPE REF TO if_fsi_view_ext.

  FIELD-SYMBOLS <local_view_extension> TYPE sfsg_def_d.
  FIELD-SYMBOLS <ls_vext_name> TYPE sfsg_def_key.
  FIELD-SYMBOLS <local_view_field> TYPE LINE OF sfsg_view_fields_t.
  FIELD-SYMBOLS <local_extended_view>.

  lv_view = extended_view.
  lo_view_repos = cl_fsi_view_repository=>get_instance( ).
  TRY.
      lo_view = lo_view_repos->get_view(
        i_view_name = lv_view
        ).
    CATCH cx_sfs_not_found.

  ENDTRY.

if lo_view is not initial.
  lt_vext_names = lo_view->get_extension_names( ).

  LOOP AT lt_vext_names ASSIGNING <ls_vext_name>.
    TRY.
        lo_view_ext = lo_view_repos->get_extension(
          i_extension = <ls_vext_name>-def_name
          i_as4local  = <ls_vext_name>-as4local
          ).
      CATCH cx_sfs_not_found cx_gfs_origin_not_found.
        CONTINUE.
    ENDTRY.

    PERFORM eewfsiextensioncheck_eewdb USING <ls_vext_name>-def_name
                                         CHANGING createdbyeew_l.

    lt_view_flds = lo_view_ext->if_fsi_view~get_view_fields( ).

    DATA: tl_view_fields TYPE /SF0A0001/VIEW_FIELDS_T.
    LOOP AT lt_view_flds ASSIGNING <local_view_field>.
      tl_view_fields-view_field_name = <local_view_field>-view_field_name.
      tl_view_fields-bo_node_alias = <local_view_field>-bo_node_alias.
      tl_view_fields-bo_node_attribute = <local_view_field>-bo_node_attribute.
      tl_view_fields-extension_of = lv_view.
      tl_view_fields-def_name = <ls_vext_name>-def_name.
      IF createdbyeew_l = abap_false.
         APPEND tl_view_fields TO lt_view_fields.
      ENDIF.
*      IF NOT ( devtool = abap_false AND createdbyeew = abap_true ).
*        IF allswc = abap_true.
*          APPEND tl_view_fields TO lt_view_fields.
*        ENDIF.
*
*        IF targeswc = abap_true.
*          IF tl_view_fields-bo_node_attribute CP inputswcpatternabap OR tl_view_fields-view_field_name CP inputswcpatternabap .
*            APPEND tl_view_fields TO it_view_fields.
*          ENDIF.
*        ENDIF.
*      ENDIF.
    ENDLOOP.
  ENDLOOP.
  endif.

ENDFORM.                    "Append_view_fields
FUNCTION /SF0A0001/FE_GET_AVAIL_SPACE.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(PROXY_DT) TYPE  TYPENAME
*"----------------------------------------------------------------------

DATA lv_number_of_fields  TYPE i.
DATA lv_number_of_bytes   TYPE i.
DATA ls_extension_include TYPE eewst_datatype_registry.

ls_extension_include = cl_eew_extensionregistry=>get_prxdtype_extinclude( proxy_dt ).

cl_eew_extensionregistry=>get_available_space(
            EXPORTING
              iv_proxy_data_type  = proxy_dt
            IMPORTING
              ev_number_of_fields = lv_number_of_fields
              ev_number_of_bytes  = lv_number_of_bytes ).

WRITE: 'number_of_fields: ', lv_number_of_fields.
NEW-LINE.
WRITE: 'number_of_bytes: ', lv_number_of_bytes .



ENDFUNCTION.
FUNCTION /SF0A0001/FE_GET_TR_CONTAINED.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IN_TR_ID) TYPE  /SF0A0001/TT_TR_TABLE
*"  EXPORTING
*"     VALUE(OUT_DATA) TYPE  /SF0A0001/TT_TR_OBJECTLIST
*"----------------------------------------------------------------------

    data: lt_assigned_requests TYPE trwbo_request_headers,
          ls_assigned LIKE LINE OF lt_assigned_requests,
          ls_data TYPE E071,
          ls_out TYPE /SF0A0001/TY_TR_OBJECTLIST,
        lt_data TYPE STANDARD TABLE OF E071.

    CHECK in_tr_ID IS NOT INITIAL.

    SELECT  e070~trkorr e070~trfunction e070~trstatus e070~tarsystem
           e070~korrdev e070~as4user e070~as4date e070~as4time
           e070~strkorr e070c~client e070c~tarclient e07t~as4text
           INTO CORRESPONDING FIELDS OF TABLE lt_assigned_requests
           FROM ( e070 LEFT JOIN e070c ON e070~trkorr = e070c~trkorr )
                       LEFT JOIN e07t  ON e070~trkorr = e07t~trkorr
           FOR ALL ENTRIES IN IN_TR_ID
           WHERE strkorr = IN_TR_ID-table_line.

    IF lt_assigned_requests IS NOT INITIAL.
      SELECT * INTO TABLE lt_data FROM E071 FOR ALL ENTRIES IN lt_assigned_requests
          WHERE TRKORR = lt_assigned_requests-TRKORR AND pgmid IN ('R3TR','LIMU' ) AND
            object in ('ENHO','CLAS','METH','EEW6','TABU' ).
    ELSE.

      SELECT * INTO TABLE lt_data FROM E071 FOR ALL ENTRIES IN in_tr_id
          WHERE TRKORR = in_tr_id-table_line AND  pgmid IN ('R3TR','LIMU' ) AND
            object in ('ENHO','CLAS','METH','EEW6','TABU' ).
      CHECK lt_data IS NOT INITIAL.
      SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_assigned_requests FROM e07t FOR ALL ENTRIES IN
         lt_data WHERE TRKORR  = lt_data-TRKORR.

    ENDIF.

    CHECK lines( lt_data ) <> 0.

    LOOP AT lt_data INTO ls_data.
       CLEAR: ls_out.
       ls_out-source_tr = ls_data-trkorr.
       READ TABLE lt_assigned_requests INTO ls_assigned WITH KEY trkorr = ls_data-trkorr.
       IF sy-subrc = 0.
          ls_out-target_tr = ls_assigned-strkorr.
       ENDIF.
       ls_out-OBJ_TYPE = ls_data-OBJECT.
       ls_out-obj_name = ls_data-obj_name.
       IF ls_out-obj_type = 'EEW6'.
          PERFORM get_extension_detail USING ls_out-obj_name CHANGING ls_assigned-as4text.
       ENDIF.
       ls_out-text = ls_assigned-as4text.
       APPEND ls_out TO out_data.
    ENDLOOP.

ENDFUNCTION.

FORM get_extension_detail USING extension_id TYPE E071-obj_name CHANGING text TYPE trwbo_request_header-as4text.

  DATA: ls_entry TYPE /EXT/C_FIELD,
        bo_name TYPE SESF_BUSINESS_OBJECT,
        bo_node_name TYPE SESF_BUSINESS_OBJECT_node.
  SELECT SINGLE * INTO ls_entry FROM /EXT/C_FIELD WHERE status = 'A' AND extension_id = extension_id.
  CHECK sy-subrc = 0.

  IF ls_entry-BO_NODE_DESCR_ID IS NOT INITIAL.
    CALL METHOD /EXT/CL_MODEL_ADAPTER=>GET_BO_NODE_BY_DESCRIPTOR_ID
      EXPORTING
        IV_NODE_DESCR_ID = ls_entry-BO_NODE_DESCR_ID
      IMPORTING
        EV_BO_NAME       = bo_name
        EV_BO_NODE_NAME  = bo_node_name.

      CONCATENATE text '|Extended Bo Name:' bo_name '|Extended BO Node Name:' bo_node_name INTO text SEPARATED BY space.
  ELSE.
      CONCATENATE text '|Extended Data Type:' ls_entry-proxy_Data_type INTO text SEPARATED BY space.
  ENDIF.
ENDFORM.
FUNCTION /SF0A0001/FE_GET_VIEW_EXTENSIO.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  EXPORTING
*"     REFERENCE(TABLE) TYPE  /SF0A0001/SFSG_DEF_D_T
*"----------------------------------------------------------------------


SELECT * FROM sfsg_def_d INTO TABLE table WHERE def_name LIKE  '%SFA_____%'.






ENDFUNCTION.
8. /SF0A0001/CL_FORM_MIGRATION
private section.
*"* private components of class /SF0A0001/CL_FORM_MIGRATION
*"* do not include other source files here!!!

  types:
    BEGIN OF ty_Data,
           root_guid TYPE /CDF/OBJECT_GUID,
           root_id TYPE AP_BTD_ID,
           item_guid TYPE /CDF/OBJECT_GUID,
           item_id TYPE AP_BTD_ITEM_ID,
         END OF ty_data .
  types:
    tt_data TYPE STANDARD TABLE OF ty_Data WITH KEY root_id item_id .

  data MV_ERROR type ABAP_BOOL .
  data MS_DATA type TY_DATA .
  data mt_root_DB   TYPE STANDARD TABLE OF CDAD_DOCHD.
  data mt_item_db   TYPE STANDARD TABLE OF CDAD_DOCIT.
  data mt_task   TYPE STANDARD TABLE OF CDAD_DOCIT.
  data MV_FILE TYPE localfile.
  data mi_data TYPE soi_generic_table.
  data MV_ROW  TYPE I.
  data MV_COL  TYPE I VALUE 5.
  data MT_DATA type TT_DATA .
  data:
    mt_log_message TYPE STANDARD TABLE OF /SF0A0001/log .
  data MS_LOG_MESSAGE type /SF0A0001/LOG .

  methods ADD_LOG
    importing
      !MSGTY type SYMSGTY
      !ID type STRING
      !TEXT1 type SYMSGV optional
      !TEXT2 type SYMSGV optional
      !TEXT3 type SYMSGV optional
      !TEXT4 type SYMSGV optional
      !MSGNO type SYST-MSGNO .

  methods ADD_LOGS
    importing
      !ID type STRING
      !MSGNO type SYST-MSGNO .

  methods INITIAL_EXCEL_PROXY .
method CONSTRUCTOR.

  DATA: lr_lcp_facade           TYPE REF TO if_esf_lcp_facade,
        lr_lcp                  TYPE REF TO if_esf_lcp,
        lt_item                 TYPE IF_APCRM_CTD_TEMPLATE=>TT_ITEM,
        ls_item                 TYPE REF TO IF_APCRM_CTD_TEMPLATE=>TY_ITEM,
        lt_so_root_id           TYPE sesf_bo_nodE_id_tab,
        ls_root_db              TYPE REF TO CDAD_DOCHD.

  CLEAR: ms_data,mt_data,mt_log_message,ms_log_message,
         mt_root_db,mi_data.

  mv_file = p_file.
  mv_row  = p_row.

  CALL METHOD cl_esf_lcp_factory=>get_lcp_facade " Factory class to get an instance to the LCP facade
    RECEIVING
      out_lcp_facade = lr_lcp_facade.

  lr_lcp = lr_lcp_facade->get_lcp( 'SALES_ORDER' ).

  SELECT GUID OBJECT_ID TYPE_code INTO CORRESPONDING FIELDS OF TABLE mt_root_DB FROM CDAD_DOCHD BYPASSING BUFFER WHERE TYPE_CODE = '114'.

  CHECK sy-subrc = 0.

  LOOP AT mt_root_db REFERENCE INTO ls_root_Db.
     APPEND ls_root_Db->guid TO lt_so_root_id.
  ENDLOOP.

  CALL METHOD lr_lcp->retrieve_by_association
   EXPORTING
        in_bo_node_name     = 'ROOT'
        in_association_name = 'ITEM'
        in_node_ids         = lt_so_root_id
        in_fill_data        = 'X'
   IMPORTING
        out_data           = lt_item.

  LOOP AT lt_item REFERENCE INTO ls_item.
     READ TABLE mt_root_db REFERENCE INTO ls_root_db WITH KEY guid = ls_item->parent_node_id.
     CHECK sy-subrc = 0.
     CLEAR: ms_data.
     SHIFT ls_root_db->object_id LEFT DELETING LEADING '0'.
     ms_data-root_guid = ls_root_db->guid.
     ms_data-root_id = ls_root_db->object_id.
     ms_data-item_guid = ls_item->node_id.
     SHIFT ls_item->id LEFT DELETING LEADING '0'.
     ms_data-item_id = ls_item->id.
     APPEND ms_Data to mt_data.
   ENDLOOP.

   IF mt_data IS INITIAL.
      mv_error = abap_true.
      MESSAGE 'There is errors when Loading SalesOrder Instance From Persistency' TYPE 'E'
        DISPLAY LIKE 'E'.
      RETURN.
   ENDIF.

   DATA: ls_root_num TYPE SYMSGV,
         lv_temp TYPE i,
         ls_item_num TYPE SYMSGV.

   ls_root_num = lv_temp = lines( mt_root_db ).
   ls_item_num = lv_temp = lines( lt_item ).

   CALL METHOD me->ADD_LOG
     EXPORTING
       MSGTY  = 'S'
       ID     = 'STEP1:SalesOrder Instance Load from Persistency'
       TEXT1  = ls_root_num
       TEXT2  = ls_item_num
       MSGNO  = '001'.

   initial_excel_proxy( ).

endmethod.
method RUN.

DATA: lr_data TYPE REF TO SOI_GENERIC_ITEM,
      lv_left TYPE i,
      lv_root_id TYPE AP_BTD_ID,
      ls_item_db LIKE LINE OF mt_item_db,
      lr_formatted_data    TYPE REF TO ty_data,
      lv_item_id TYPE AP_BTD_ITEM_ID,
      lv_description TYPE string,
      lv_index TYPE i.

lv_left = mv_row.

CLEAR: mt_log_message.

" INDEX 1 : SalesOrder ID
" INDEX 2 : SalesOrder item ID

WHILE lv_left > 0.
  lv_index = 1.

  CLEAR: lv_root_id, lv_item_id,lv_description.
  DO mv_col TIMES.
     READ TABLE mi_data REFERENCE INTO lr_data INDEX lv_index.
     IF sy-subrc <> 0.
        ADD 1 TO lv_index.
        CONTINUE.
     ENDIF.

     CASE lv_index.
       WHEN 1.
         lv_root_id = lr_data->value.
       WHEN 2.
         lv_item_id = lr_data->value.
       WHEN 3.
         lv_description = lr_data->value.
     ENDCASE.

     ADD 1 TO lv_index.
  ENDDO.

  lv_left = lv_left - mv_col.

  IF lv_root_id IS INITIAL OR lv_item_id IS INITIAL OR lv_description IS INITIAL.
    CONTINUE.
  ENDIF.

  READ TABLE mt_data REFERENCE INTO lr_formatted_data WITH KEY
     root_id = lv_root_id item_id = lv_item_id.
  IF sy-subrc <> 0.
     CONTINUE.
  ENDIF.

  CLEAR: ls_item_db.

  SELECT SINGLE * INTO ls_item_Db FROM CDAD_DOCIT WHERE guid =
    lr_formatted_data->item_guid.

  IF sy-subrc <> 0.
     CONTINUE.
  ENDIF.

  ls_item_db-description = lv_description.
  APPEND ls_item_db TO mt_task.
  CLEAR: ms_log_message.
  ms_log_message-MSGTY = 'S'.
  ms_log_message-MSG_TEXT_1 = lr_formatted_data->root_id.
  ms_log_message-MSG_TEXT_2 = lr_formatted_data->root_guid.
  ms_log_message-MSG_TEXT_3 = lr_formatted_data->item_id.
  ms_log_message-MSG_TEXT_4 = lr_formatted_data->item_guid.
  APPEND ms_log_message TO mt_log_message.

ENDWHILE.

IF mt_task IS NOT INITIAL.
   UPDATE CDAD_DOCIT FROM TABLE mt_task.
   ASSERT sy-subrc = 0.
   COMMIT WORK AND WAIT.
   ASSERT sy-subrc = 0.
ENDIF.

  CALL METHOD me->ADD_LOGS
     EXPORTING
       ID     = 'STEP3:SalesOrder Instance Migration OK'
       MSGNO  = '007'.

endmethod.
method ADD_LOG.
  CLEAR: ms_log_message,mt_log_message.

  ms_log_message-MSGTY = msgty.
  ms_log_message-MSG_TEXT_1 = text1.
  ms_log_message-MSG_TEXT_2 = text2.
  ms_log_message-MSG_TEXT_3 = text3.
  ms_log_message-MSG_TEXT_4 = text4.

  CONDENSE ms_log_message-msg_text_1 NO-GAPS.
  CONDENSE ms_log_message-msg_text_2 NO-GAPS.
  CONDENSE ms_log_message-msg_text_3 NO-GAPS.
  CONDENSE ms_log_message-msg_text_4 NO-GAPS.

  APPEND ms_log_message TO mt_log_message.

  CALL FUNCTION '/SF0A0001/MESSAGE_LOGGING'
    EXPORTING
      I_LOG_OBJECT                  = '/SF0A0001/TEST'
      I_EXTNUMBER                   = ID
      I_MSG_NUMBER                  = msgno
    TABLES
      T_LOG_MESSAGE                 = mt_log_message
    EXCEPTIONS
     LOG_HEADER_INCONSISTENT       = 1
     LOGGING_ERROR                 = 2
     OTHERS                        = 3.

  ASSERT sy-subrc = 0.


endmethod.
method ADD_LOGS.

  CALL FUNCTION '/SF0A0001/MESSAGE_LOGGING'
    EXPORTING
      I_LOG_OBJECT                  = '/SF0A0001/TEST'
      I_EXTNUMBER                   = ID
      I_MSG_NUMBER                  = msgno
    TABLES
      T_LOG_MESSAGE                 = mt_log_message
    EXCEPTIONS
     LOG_HEADER_INCONSISTENT       = 1
     LOGGING_ERROR                 = 2
     OTHERS                        = 3.

  ASSERT sy-subrc = 0.
endmethod.
method INITIAL_EXCEL_PROXY.

DATA:
oref_container   TYPE REF TO cl_gui_custom_container,
iref_control     TYPE REF TO i_oi_container_control,
iref_document    TYPE REF TO i_oi_document_proxy,
iref_spreadsheet TYPE REF TO i_oi_spreadsheet,
excel_row        TYPE SYMSGV,
iref_error       TYPE REF TO i_oi_error.

DATA:
v_document_url TYPE c LENGTH 256,
i_sheets TYPE soi_sheets_table,
wa_sheets TYPE soi_sheets,
p_file  TYPE  localfile,
wa_data       TYPE soi_generic_item,
i_ranges      TYPE soi_range_list,
i_total       TYPE i.


CALL METHOD c_oi_container_control_creator=>get_container_control
     IMPORTING
       control = iref_control
       error   = iref_error.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
  ENDIF.


  CREATE OBJECT oref_container
    EXPORTING
       container_name              = 'CONTAINER'
    EXCEPTIONS
       cntl_error                  = 1
       cntl_system_error           = 2
       create_error                = 3
       lifetime_error              = 4
       lifetime_dynpro_dynpro_link = 5
       OTHERS                      = 6.

  IF sy-subrc <> 0.
    MESSAGE e002(/SF0A0001/LOG) WITH 'Error while creating container'.
    RETURN.
  ENDIF.

  CALL METHOD iref_control->init_control
    EXPORTING
       inplace_enabled          = 'X'
       r3_application_name      = 'EXCEL CONTAINER'
       parent                   = oref_container
    IMPORTING
       error                    = iref_error
    EXCEPTIONS
       javabeannotsupported     = 1
       OTHERS                   = 2.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
  ENDIF.

  CALL METHOD iref_control->get_document_proxy
    EXPORTING
      document_type      = soi_doctype_excel_sheet
      no_flush           = 'X'
     IMPORTING
       document_proxy     = iref_document
       error              = iref_error.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
  ENDIF.

  CONCATENATE 'FILE://' mv_file INTO v_document_url.

  CALL METHOD iref_document->open_document
    EXPORTING
      document_title   = 'Excel'
      document_url     = v_document_url
      no_flush         = 'X'
      open_inplace     = 'X'
    IMPORTING
      error            = iref_error.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
    MESSAGE e003(/SF0A0001/LOG).

  ENDIF.

  CALL METHOD iref_document->get_spreadsheet_interface
     EXPORTING
       no_flush        = 'X'
    IMPORTING
      error           = iref_error
      sheet_interface = iref_spreadsheet.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
    MESSAGE e004(/SF0A0001/LOG).
  ENDIF.

  CALL METHOD iref_spreadsheet->get_sheets
      EXPORTING
       no_flush = ''
     IMPORTING
       sheets   = i_sheets
       error    = iref_error.

  IF iref_error->has_failed = 'X'.
    CALL METHOD iref_error->raise_message
      EXPORTING
        type = 'E'.
    MESSAGE e004(/SF0A0001/LOG).
  ENDIF.

  READ TABLE i_sheets INTO wa_sheets INDEX 1.

    CALL METHOD iref_spreadsheet->select_sheet
       EXPORTING
          name     = wa_sheets-sheet_name
          no_flush = ''
      IMPORTING
          error    = iref_error.

    IF iref_error->has_failed = 'X'.
      CALL METHOD iref_error->raise_message
        EXPORTING
          type = 'E'.
      MESSAGE e004(/SF0A0001/LOG).
    ENDIF.

    CALL METHOD iref_spreadsheet->set_selection
      EXPORTING
        top     = 1
        left    = 1
        rows    = mv_row
        columns = 5.

    CALL METHOD iref_spreadsheet->insert_range
      EXPORTING
        name     = 'Test'
        rows     = mv_row
        columns  = MV_COL
        no_flush = ''
      IMPORTING
        error    = iref_error.

    IF iref_error->has_failed = 'X'.
      CALL METHOD iref_error->raise_message
        EXPORTING
          type = 'E'.
      MESSAGE e004(/SF0A0001/LOG).
    ENDIF.

    CALL METHOD iref_spreadsheet->get_ranges_data
       EXPORTING
         no_flush  = ''
         all       = 'X'
       IMPORTING
         contents  = mi_data
         error     = iref_error
       CHANGING
         ranges    = i_ranges.

    IF mi_data IS NOT INITIAL.

       excel_row  = lines( mi_data ) / mv_row.
       CALL METHOD me->ADD_LOG
         EXPORTING
           MSGTY  = 'S'
           ID     = 'STEP2:Read Data from Excel Successfully!'
           TEXT1  = excel_row
           MSGNO  = '005'.

    ENDIF.
endmethod.
9. /SF0A0001/BADI_BO_NAME
*"* components of interface /SF0A0001/SCAN_CONSTANT
interface /SF0A0001/SCAN_CONSTANT
  public .


  constants C_COMMENT type STRING value '*'. "#EC NOTEXT
  constants C_INSERT type STRING value 'INSERT'. "#EC NOTEXT
  constants C_APPEND type STRING value 'APPEND'. "#EC NOTEXT
  constants C_MODIFY type STRING value 'MODIFY'. "#EC NOTEXT
  constants C_GET_LCP type STRING value 'GET_LCP'. "#EC NOTEXT
  constants C_IN_QUERY_NAME type STRING value 'IN_QUERY_NAME'. "#EC NOTEXT
  constants C_IN_ACTION_NAME type STRING value 'IN_ACTION_NAME'. "#EC NOTEXT
  constants C_BO_NODE_NAME type STRING value 'IN_BO_NODE_NAME'. "#EC NOTEXT
  constants C_ASS_NAME type STRING value 'IN_ASSOCIATION_NAME'. "#EC NOTEXT
  constants C_EQUAL type STRING value '='. "#EC NOTEXT
  constants C_EXECUTE_ACTION type STRING value 'EXECUTE_ACTION'. "#EC NOTEXT
  constants C_WATER type STRING value '~'. "#EC NOTEXT
  constants C_LEFT type STRING value '('. "#EC NOTEXT
  constants C_BO_NAME type STRING value 'IN_BO_NAME'. "#EC NOTEXT
  constants C_IN_MODIFICATIONS type STRING value 'IN_MODIFICATIONS'. "#EC NOTEXT
  constants C_END type STRING value '.'. "#EC NOTEXT
  constants C_RIGHT type STRING value ')'. "#EC NOTEXT
  constants C_QUOTA type STRING value ''''. "#EC NOTEXT
  constants C_COMMENT1 type STRING value '"'. "#EC NOTEXT
  constants C_REFER type STRING value '=>'. "#EC NOTEXT
  constants C_OUT_DATA type STRING value 'OUT_DATA'. "#EC NOTEXT
  constants C_OUT_LINK type STRING value 'OUT_LINKS'. "#EC NOTEXT
  constants C_BO_ROOT type I value 1. "#EC NOTEXT
  constants C_BO_NODE type I value 2. "#EC NOTEXT
  constants C_BO_ASS type I value 3. "#EC NOTEXT
  constants C_BO_QUERY_NAME type I value 6. "#EC NOTEXT
  constants C_BO_QUERY_NODE type I value 5. "#EC NOTEXT
  constants C_BO_ACTION_NAME type I value 7. "#EC NOTEXT
  constants C_BO_FIELD type I value 4. "#EC NOTEXT
  constants C_TYPE type STRING value 'TYPE'. "#EC NOTEXT
  constants C_REFERENCE type STRING value '->'. "#EC NOTEXT
  constants C_COMMA type STRING value ','. "#EC NOTEXT
  constants C_FIELD type STRING value '-'. "#EC NOTEXT
  constants C_TABLE_KEY type STRING value 'WITH KEY'. "#EC NOTEXT
  constants C_LOOP_AT type STRING value 'LOOP AT'. "#EC NOTEXT
  constants C_INTO type STRING value 'INTO'. "#EC NOTEXT
  constants C_WHERE type STRING value 'WHERE'. "#EC NOTEXT
  constants C_ASSIGNING type STRING value 'ASSIGNING'. "#EC NOTEXT
  constants C_MODIFY_BO_NODE type STRING value 'BO_NODE_NAME'. "#EC NOTEXT
  constants C_READ_TABLE type STRING value 'READ TABLE'. "#EC NOTEXT
  constants C_IMPORTING type STRING value 'IMPORTING'. "#EC NOTEXT
  constants C_QUERY type STRING value 'QUERY'. "#EC NOTEXT
  constants C_REF type STRING value 'REF'. "#EC NOTEXT
  constants C_TO type STRING value 'TO'. "#EC NOTEXT
  constants C_BADI type I value 1. "#EC NOTEXT
  constants C_MASS type I value 3. "#EC NOTEXT
  constants C_EXPORT_WRITE type I value 5. "#EC NOTEXT
  constants C_EXPORT type I value 4. "#EC NOTEXT
  constants C_EXIT type I value 2. "#EC NOTEXT
  constants C_LCP_FACADE type STRING value '>GET_LCP_FACADE('. "#EC NOTEXT
  constants C_LCP_DEFINE type STRING value 'TYPE REF TO IF_ESF_LCP'. "#EC NOTEXT
  constants C_FACADE type STRING value 'FACADE'. "#EC NOTEXT
  constants C_FIND_LCP_UP_LIMIT type I value 10. "#EC NOTEXT
  constants C_FIND_LCP_DOWN_LIMIT type I value 4. "#EC NOTEXT
  constants C_OUT_LCP type STRING value 'OUT_LCP'. "#EC NOTEXT
  constants C_CO_BO_NAME type STRING value 'CO_BO_NAME'. "#EC NOTEXT
  constants C_TYPE_BADI type STRING value 'BADI_IMPL'. "#EC NOTEXT
  constants C_TYPE_EXIT type STRING value 'CLASENH'. "#EC NOTEXT
  constants C_ROOT type STRING value 'ROOT'. "#EC NOTEXT
  constants C_USED_ADDRESS type CHAR1 value 'A'. "#EC NOTEXT
  constants C_ADDRESS type CHAR1 value 'B'. "#EC NOTEXT
  constants C_CALL_METHOD type STRING value '>'. "#EC NOTEXT
  constants C_MOVE type STRING value 'MOVE-CORRESPONDING'. "#EC NOTEXT
endinterface.
private section.
*"* private components of class /SF0A0001/BADI_BO_NAME
*"* do not include other source files here!!!

  types SEOR_IMPLEMENTING_R type VSEOIMPLEM .
  types SEOP_SOURCE_STRING type RSWSOURCET .
  types:
    SEOR_IMPLEMENTINGS_R TYPE STANDARD TABLE OF SEOR_IMPLEMENTING_R
    WITH KEY CLSNAME REFCLSNAME VERSION .
  types:
    BEGIN OF ty_line,
           line_num TYPE i,
           line_text TYPE string,
         END OF ty_line .
  types:
    tt_line TYPE STANDARD TABLE OF ty_line WITH KEY line_num .
  types:
    BEGIN OF ty_lcp_map,
           lcp_name TYPE string,
           bo_name TYPE string,
         END OF ty_lcp_map .
  types:
    tt_lcp_map TYPE STANDARD TABLE OF ty_lcp_map WITH KEY lcp_name .
  types:
    BEGIN OF ty_variable_line,
           variable_name TYPE string,
           variable_type TYPE string,
         END OF ty_variable_line .
  types:
    tt_variable_line TYPE STANDARD TABLE OF ty_variable_line WITH KEY variable_name .
  types:
    BEGIN OF ty_report_line,
           obj_name TYPE string,
           method_name TYPE string,
           icon TYPE string,
           bo_attr_type TYPE string,
           bo_attr_name TYPE string,
           line_num TYPE i,
           line_text TYPE string,
         END OF ty_report_line .
  types:
    tt_report_line TYPE STANDARD TABLE OF ty_report_line .
  types:
    BEGIN OF ty_excel_line,
        bo_name TYPE string,
        bo_node_name TYPE string,
    END OF ty_excel_line .
  types:
    tt_excel_line TYPE STANDARD TABLE OF ty_excel_line WITH KEY bo_name .

  class-data LT_EXCEL_TAB type TT_EXCEL_LINE .
  class-data MT_HELPER_CLASS_TAB type STRING_TABLE .
  type-pools ABAP .
  class-data MV_IN_HELPER_CLASS type ABAP_BOOL value ABAP_FALSE. "#EC NOTEXT .
  class-data MV_SOFTWARE_COMPONENT type CHAR10 .
  class-data GR_ALV type ref to CL_SALV_TABLE .
  class-data LV_EXIT_NAME type STRING .
  class-data LT_LCP_MAP type TT_LCP_MAP .
  class-data LT_LCP_TABLE type STRING_TABLE .
  class-data LV_WORK_MODE type I value 0. "#EC NOTEXT .
  class-data LV_FIRST_MEET type I value 0. "#EC NOTEXT .
  class-data LT_STRUCT_TAB type STRING_TABLE .
  class-data LT_OUTDATA_TAB type TT_VARIABLE_LINE .
  class-data LT_BO_REPORT_TAB type TT_REPORT_LINE .
  class-data LV_CURRENT_METHOD type STRING .
  class-data LV_ERROR_FLAG type I .
  class-data LT_WORKING_POOL type TT_LINE .
  type-pools SEOP .
  class-data LT_WORKING_SOURCE type SEOP_SOURCE_STRING .
  class-data LV_BADI_IMPL_NAME type STRING .

  class-methods SCAN_BO_WRITE .
  class-methods HANDLE_VARIABLE_EQUAL_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_MOVE_CORRESPONDING
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_MODIFY_DATA
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_HELPER_CLASS
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_BO_ACTION
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_EXIT_HELPER_CLASS .
  class-methods HANDLE_EXECUTE_ACTION
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_EMBEDDED_CALL_METHOD
    importing
      !IN_CURRENT_LINE type I .
  class-methods GET_HELPER_CLASS_NAME
    importing
      !IN_LINE_TEXT type STRING
    returning
      value(OUT_CLASS_NAME) type STRING .
  class-methods FIND_REAL_MODIFY_VARIABLE
    importing
      !IN_CURRENT_LINE type I .
  class-methods FIND_REAL_ACTION_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods FIND_REAL_ACTION_BO_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods DO_SUMMARY .
  class-methods _HANDLE_GET_QUERY_DATA
    importing
      !IN_CURRENT_LINE type I
      !IN_TYPE type I .
  class-methods HANDLE_GET_QUERY_DATA
    importing
      !IN_CURRENT_LINE type I .
  class-methods EXCEL_HIGHLIGHT_NEEDED
    importing
      !IN_VALUE type ANY
    returning
      value(OUT_RESULT) type CHAR1 .
  class-methods EXPORT .
  class-methods PREPARE_FOR_EXPORT .
  class-methods DISPLAY_EXPORT .
  class-methods RECORD_EXCEL
    importing
      !IN_LINE type TY_REPORT_LINE
      !IN_TYPE type I .
  class-methods BUILD_PATH_BY_INTERFACE
    importing
      !IN_BO_ATTR_NAME type STRING
    exporting
      !OUT_BO_NAME type STRING .
  class-methods TRY_FIND_LCP_VARIABLE
    importing
      !IN_BO_ATTR_NAME type STRING
      !IN_CURRENT_LINE type I .
  class-methods FILL_LCP_MAP_NEXT_LINE
    importing
      !IN_CURRENT_LINE type I
      !IN_BO_ATTR_NAME type STRING .
  class-methods FILL_LCP_TABLE .
  class-methods INTERFACE2CONSTANT
    importing
      !IN_INTERFACE type STRING
    exporting
      !OUT_CONSTANT type STRING .
  class-methods UP_CHECK_IN_BO_NAME
    importing
      !IN_CURRENT_LINE type I
    exporting
      !OUT_BO_NAME type STRING .
  class-methods POPULATE_WHOLE_PATH
    importing
      !IN_BO_ATTR_NAME type STRING
      !IN_CURRENT_LINE type I
    exporting
      !OUT_WHOLE_PATH type STRING .
  class-methods GET_LCP_IN_SOURCE
    importing
      !IN_SOURCE_CODE type STRING
    exporting
      !OUT_LCP_NAME type STRING .
  class-methods LOG_WITH_TEXT
    importing
      !IN_TEXT type STRING .
  class-methods EXTRACT_STRU_FROM_DIFF_TAB
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods FILL_POST_EXIT_WORKING_POOL .
  class-methods GET_IMPL_CLASS_NAME
    importing
      !IN_ENH_NAME type ENHNAME .
  class-methods HANDLE_OBJ_NOT_IN_TAB
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods EXTRACT_OUTPUT_DATA
    importing
      !IN_SOURCE_CODE type STRING .
  class-methods HANDLE_GET_IMPORT_DATA
    importing
      !IN_CURRENT_LINE type I .
  class-methods RETRIEVE_BO_ATTR_FROM_STRU
    importing
      !IN_STRU_NAME type STRING .
  class-methods HANDLE_STRUC_TABLE .
  class-methods EXTRACT_STRU_FROM_LOOP_AT_INTO
    importing
      !IN_SOURCE_CODE type STRING .
  class-methods EXTRACT_STRU_FROM_LOOP_AT_ASSI
    importing
      !IN_SOURCE_CODE type STRING .
  class-methods HANDLE_LOOP_AT
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_READ_TABLE
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods GET_BO_ATTR_FROM_LOOP_AT_WHERE
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods GET_BO_ATTR_FROM_WITH_KEY
    importing
      !IN_NAME type STRING
      !IN_TYPE type STRING
      !IN_CURRENT_LINE type I .
  class-methods GET_VARIABLE_TYPE
    importing
      !IN_NAME type STRING
    exporting
      !OUT_TYPE type STRING .
  class-methods RETRIEVE_BO_ATTR_FROM_TAB .
  class-methods DISPLAY .
  class-methods RECORD
    importing
      !IN_CURRENT_LINE type I
      !IN_BO_ATTR_NAME type STRING
      !IN_NAME_TYPE type I .
  class-methods ALPHA_CONVERSION
    importing
      !IN_NAME type STRING
    exporting
      !OUT_NAME type STRING .
  class-methods CONDENSE_STRING
    importing
      !IN_STRING type STRING
    exporting
      !OUT_STRING type STRING .
  class-methods HANDLE_GET_OUT_DATA_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods SCAN_BO .
  class-methods GET_BADI_INFO
    importing
      !IM_BADI_NAME type SOBJ_NAME .
  class-methods FILL_SOURCE_TABLE .
  class-methods GET_INTERFACE_SOURCE .
  class-methods HANDLE_GET_LCP
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_BO_NODE_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_ASS_NAME
    importing
      !IN_CURRENT_LINE type I .
  class-methods HANDLE_GET_LCP_NEXT_LINE
    importing
      !IN_CURRENT_LINE type I .
method RUN_WRITE_EXPORT.
  DATA: lt_table TYPE TABLE OF /SF0A0007/SCABAP,
        ls_line TYPE /SF0A0007/SCABAP,
        lv_text TYPE string.

  CLEAR: mt_helper_class_tab.
  lv_work_mode = in_work_mode.
  SELECT ENH_TYPE ENH_NAME FROM /SF0A0007/SCABAP INTO CORRESPONDING FIELDS OF TABLE lt_table. "#EC CI_NOWHERE
  LOOP AT lt_Table INTO ls_line.
    CASE ls_line-ENH_TYPE.
       WHEN /SF0A0001/SCAN_CONSTANT=>C_TYPE_EXIT.
          CONCATENATE 'Checking:' ls_line-ENH_NAME INTO lv_text SEPARATED BY SPACE. "#EC NOTEXT
          log_with_text( lv_text ).
          RUN_WITH_EXIT( EXPORTING in_enh_name = ls_line-ENH_NAME in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_EXPORT_WRITE ).
       WHEN OTHERS.

    ENDCASE.
  ENDLOOP.

  Handle_exit_helper_class( ).
  DISPLAY_EXPORT( ).

endmethod.
method RUN_MASS.
  DATA: lt_table TYPE TABLE OF /SF0A0007/SCABAP,
        ls_line TYPE /SF0A0007/SCABAP,
        lv_text TYPE string.

  lv_work_mode = in_work_mode.
  SELECT ENH_TYPE ENH_NAME FROM /SF0A0007/SCABAP INTO CORRESPONDING FIELDS OF TABLE lt_table. "#EC CI_NOWHERE
  LOOP AT lt_Table INTO ls_line.
    CASE ls_line-ENH_TYPE.
       WHEN /SF0A0001/SCAN_CONSTANT=>C_TYPE_BADI.
          CONCATENATE 'Checking:' ls_line-ENH_NAME INTO lv_text SEPARATED BY SPACE. "#EC NOTEXT
          log_with_text( lv_text ).
          RUN_WITH_BADI( EXPORTING in_badi_enh_name = ls_line-ENH_NAME in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_MASS ).
       WHEN /SF0A0001/SCAN_CONSTANT=>C_TYPE_EXIT.
          CONCATENATE 'Checking:' ls_line-ENH_NAME INTO lv_text SEPARATED BY SPACE. "#EC NOTEXT
          log_with_text( lv_text ).
          RUN_WITH_EXIT( EXPORTING in_enh_name = ls_line-ENH_NAME in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_MASS ).
       WHEN OTHERS.

    ENDCASE.
  ENDLOOP.

  IF in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_MASS.
    DISPLAY( ).
  ELSEIF in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_EXPORT.
    DISPLAY_EXPORT( ).
  ENDIF.
endmethod.
method SORT_BY_TYPE.
  CHECK lt_bo_report_tab IS NOT INITIAL.
  SORT lt_bo_report_tab BY bo_attr_type.
  CHECK gr_alv IS NOT INITIAL.
  gr_alv->refresh( ).
  gr_alv->display( ).

endmethod.
method RUN_WITH_BADI.
  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.

  DATA: lv_class TYPE SEOCLSKEY,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method.
  CLEAR:
     lt_working_pool,
     lt_working_source,
     lv_badi_impl_name,
     lv_current_method,
     lv_error_flag,
     lt_method,
     gr_alv,
     lv_exit_name,
     method_key,
     ls_method,
     LT_LCP_TABLE,
     lt_outdata_tab,
     LT_STRUCT_TAB,
     lv_first_meet,
     lt_lcp_map.

  lv_work_mode = in_work_mode.
  IF lv_work_mode <> /SF0A0001/SCAN_CONSTANT=>C_MASS.
     CLEAR: lt_bo_report_tab.
  ENDIF.

  get_impl_class_name( EXPORTING in_enh_name = in_badi_enh_name ).

  CHECK lv_badi_impl_name IS NOT INITIAL.

  GET_INTERFACE_SOURCE( ).

  FILL_SOURCE_TABLE( ).

  SCAN_BO( ).

  lv_class-CLSNAME = lv_badi_impl_name.
  CALL FUNCTION 'SEO_METHOD_READ_ALL'
    EXPORTING
       CIFKEY  = lv_class
    IMPORTING
       methods = lt_method.

  LOOP AT lt_method INTO ls_method.
    CLEAR: method_key,lt_working_source.
    method_key-CLSNAME = lv_badi_impl_name.
    method_key-CPDNAME = ls_method-CMPname.
    CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
      EXPORTING
        MTDKEY = method_key
      IMPORTING
        SOURCE_expanded = lt_working_source.
    lv_current_method = ls_method-CMPname.
    FILL_SOURCE_TABLE( ).
    SCAN_BO( ).
  ENDLOOP.

  CHECK lv_work_mode <> /SF0A0001/SCAN_CONSTANT=>C_MASS.
  DISPLAY( ).
endmethod.

method F4_HELP_FOR_BADI.
  TYPES:
        BEGIN OF f4list_s,
           badi   TYPE ENHNAME,
        END OF f4list_s.

  DATA: lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        ls_f4 TYPE f4list_s,
        lt_f4 TYPE TABLE OF f4list_s.

  SELECT ENHNAME ACTIVE FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME LIKE '/SFA%'.

  LOOP AT lt_badi_table INTO ls_badi.
     CLEAR ls_f4.
     ls_f4-badi = ls_badi-enhname.
     APPEND ls_f4 TO lt_f4.
  ENDLOOP.

  IF lt_f4 IS INITIAL.
     RETURN.
  ENDIF.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'BADIIMPL_ENH'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = iv_dynprofld
      value_org       = 'S'
    TABLES
      value_tab       = lt_f4
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
endmethod.

method F4_HELP_FOR_EXIT.
  TYPES:
        BEGIN OF f4list_s,
           badi   TYPE ENHNAME,
        END OF f4list_s.

  DATA: lt_badi_table TYPE TABLE OF enhsort,
        ls_badi TYPE enhsort,
        ls_f4 TYPE f4list_s,
        lv_name TYPE string,
        lt_f4 TYPE TABLE OF f4list_s.

  SELECT enhname FROM enhsort INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE version = 'A' AND ENHNAME LIKE '/SFA%'. "#EC CI_GENBUFF

  LOOP AT lt_badi_table INTO ls_badi.
     CLEAR ls_f4.
     ls_f4-badi = ls_badi-enhname.
     APPEND ls_f4 TO lt_f4.
  ENDLOOP.

  IF lt_f4 IS INITIAL.
     RETURN.
  ENDIF.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'ENHSORT'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = iv_dynprofld
      value_org       = 'S'
    TABLES
      value_tab       = lt_f4
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
endmethod.

method RUN_WITH_EXIT.
  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.

  DATA: lv_class TYPE SEOCLSKEY,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method.
  CLEAR:
     lt_working_pool,
     lt_working_source,
     lv_badi_impl_name,
     lv_current_method,
     lv_error_flag,
     lt_method,
     gr_alv,
     mv_software_component,
     lv_exit_name,
     method_key,
     LT_LCP_TABLE,
     ls_method,
     lt_outdata_tab,
     LT_STRUCT_TAB,
     lv_first_meet,
     lt_lcp_map.

  lv_work_mode = in_work_mode.

  IF lv_work_mode <> /SF0A0001/SCAN_CONSTANT=>C_MASS.
     CLEAR: lt_bo_report_tab.
  ENDIF.

  lv_badi_impl_name = in_enh_name.

  FILL_POST_EXIT_WORKING_POOL( ).

  IF in_work_mode = /SF0A0001/SCAN_CONSTANT=>C_EXPORT_WRITE.
     SCAN_BO_WRITE( ).
  ELSE.
     SCAN_BO( ).
  ENDIF.

  CHECK lv_work_mode <> /SF0A0001/SCAN_CONSTANT=>C_MASS.
  CHECK lv_work_mode <> /SF0A0001/SCAN_CONSTANT=>C_EXPORT_WRITE.
  DISPLAY( ).
endmethod.

method EXPORT_BO_REPORT.
  STATICS:lh_appl TYPE ole2_object,
          lh_workbook_list TYPE ole2_object,
          lh_workbook TYPE ole2_object,
          lh_sheet TYPE ole2_object,
          lh_columns TYPE ole2_object,
          lh_cell TYPE ole2_object,
          lh_interior TYPE ole2_object,
          lh_font TYPE ole2_object.

  DATA: lv_step TYPE string,
        lt_title TYPE string_table,
        ls_title TYPE string,
        lv_column TYPE i,
        lv_total_columns TYPE i,
        lv_row TYPE i,
        gv_filename TYPE string,
        gv_path TYPE string,
        gc_highlight TYPE char1,
        gv_fullpath TYPE string.

  FIELD-SYMBOLS: <ls_excel_line> LIKE LINE OF lt_bo_report_tab,
                 <ls_itab_cell> TYPE ANY.

  CALL METHOD cl_gui_frontend_services=>file_save_dialog
    EXPORTING
      window_title      = 'Select file' "#EC NOTEXT
      default_extension = 'xls'
      file_filter       = '*.xls'
    CHANGING
      filename          = gv_filename
      path              = gv_path
      fullpath          = gv_fullpath.

  CHECK sy-subrc = 0.
  CHECK gv_fullpath IS NOT INITIAL.
  lv_step = 'Starting Excel...'. "#EC NOTEXT
  log_with_text( lv_step ).

  CREATE OBJECT lh_appl 'Excel.Application' NO FLUSH. "#EC NOTEXT
  SET PROPERTY OF lh_appl 'SheetsInNewWorkbook' = 1 no flush. "#EC NOTEXT
  SET PROPERTY OF lh_appl 'Visible' = 0 . "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Create workbook...'. "#EC NOTEXT
  log_with_text( lv_step ).
       .
  GET PROPERTY OF lh_appl 'Workbooks' = lh_workbook_list no flush. "#EC NOTEXT
  CALL METHOD OF lh_workbook_list 'Add' = lh_workbook. "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Configure sheet...'. "#EC NOTEXT
  log_with_text( lv_step ).

  GET PROPERTY OF lh_appl 'ActiveSheet' = lh_sheet  no flush. "#EC NOTEXT
  SET PROPERTY OF lh_sheet 'Name' = 'BO'."#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Writing title...'. "#EC NOTEXT
  log_with_text( lv_step ).

  APPEND 'OBJ_NAME' TO lt_title. "#EC NOTEXT
  APPEND 'METHOD_NAME' TO lt_title. "#EC NOTEXT
  APPEND 'ICON' TO lt_title. "#EC NOTEXT
  APPEND 'BO_ATTR_TYPE' TO lt_title. "#EC NOTEXT
  APPEND 'BO_ATTR_NAME' TO lt_title. "#EC NOTEXT
  APPEND 'LINE_NUMBER' TO lt_title. "#EC NOTEXT
  APPEND 'LINE_TEXT' TO lt_title. "#EC NOTEXT

  LOOP AT lt_title INTO ls_title.
    lv_column = sy-tabix.
    CALL METHOD OF lh_appl 'Cells' = lh_cell NO FLUSH   "#EC NOTEXT
      EXPORTING
      #1 = 1
      #2 = lv_column .
    ASSERT sy-subrc = 0.
    SET PROPERTY OF lh_cell 'Value' =  ls_title no flush. "#EC NOTEXT
    GET PROPERTY OF lh_cell 'Interior' = lh_interior no flush. "#EC NOTEXT
    SET PROPERTY OF lh_interior 'ColorIndex' = 35 no flush. "#EC NOTEXT
    GET PROPERTY OF lh_cell 'Font' = lh_font no flush. "#EC NOTEXT
    SET PROPERTY OF lh_font 'Bold' = 1 no flush. "#EC NOTEXT
  ENDLOOP.

  CALL FUNCTION 'FLUSH'  "Trigger the flush explicitly
    EXCEPTIONS
      cntl_system_error = 1
      cntl_error        = 2
      OTHERS            = 3.
  ASSERT sy-subrc = 0.

  lv_total_columns = lv_column.
  lv_row = 1.

  LOOP AT lt_bo_report_tab ASSIGNING <ls_excel_line>.

    lv_row = lv_row + 1.
    lv_step = 'Handling Row:' && lv_row. "#EC NOTEXT
    log_with_text( lv_step ).
    DO lv_total_columns TIMES.
      lv_column = sy-index.
      CHECK lv_column <> 3.

      CALL METHOD OF lh_appl 'Cells' = lh_cell NO FLUSH "#EC NOTEXT
        EXPORTING
        #1 = lv_row
        #2 = lv_column.
      ASSERT sy-subrc = 0.

      ASSIGN COMPONENT lv_column OF STRUCTURE <ls_excel_line> TO <ls_itab_cell>.
      SET PROPERTY OF lh_cell 'Value' = <ls_itab_cell> no flush. "#EC NOTEXT
      CLEAR: gc_highlight.
      gc_highlight = excel_highlight_needed( in_value = <ls_itab_cell> ).
      IF gc_highlight = /SF0A0001/SCAN_CONSTANT=>C_USED_ADDRESS.
        GET PROPERTY OF lh_cell 'Interior' = lh_interior no flush. "#EC NOTEXT
        SET PROPERTY OF lh_interior 'ColorIndex' = 33 no flush. "#EC NOTEXT
      ELSEIF gc_highlight = /SF0A0001/SCAN_CONSTANT=>C_ADDRESS.
        GET PROPERTY OF lh_cell 'Interior' = lh_interior no flush. "#EC NOTEXT
        SET PROPERTY OF lh_interior 'ColorIndex' = 23 no flush. "#EC NOTEXT
      ENDIF.
    ENDDO.
  ENDLOOP.

  CALL FUNCTION 'FLUSH'  "Trigger the flush explicitly
    EXCEPTIONS
      cntl_system_error = 1
      cntl_error        = 2
      OTHERS            = 3.

  ASSERT sy-subrc = 0.
       .
  CALL METHOD OF lh_sheet 'Columns' = lh_columns NO FLUSH. "#EC NOTEXT
  CALL METHOD OF lh_columns 'Autofit'. "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Saving and closing workbook...'. "#EC NOTEXT
  log_with_text( lv_step ).

  CALL METHOD OF lh_workbook 'SaveAs' NO FLUSH "#EC NOTEXT
    EXPORTING
    #1 = gv_fullpath. "File name

  CALL METHOD OF lh_workbook 'Close' NO FLUSH. "#EC NOTEXT
  CALL METHOD OF lh_appl 'Quit' NO FLUSH. "#EC NOTEXT
  FREE OBJECT lh_appl.
  IF sy-subrc <> 0.
    CONCATENATE 'Write back to:' gv_fullpath 'error,please close it first!' INTO lv_step
    SEPARATED BY SPACE."#EC NOTEXT
    MESSAGE lv_step TYPE 'E'.
  ENDIF.
endmethod.


method SCAN_BO_WRITE.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        lv_tab_variable_define_line TYPE i,
        lv_result TYPE i,
        line_length TYPE i.

  CLEAR: lt_outdata_tab,LT_STRUCT_TAB,lt_lcp_map,LT_LCP_TABLE.

  FILL_LCP_TABLE( ).

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     IF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_GET_LCP.
        handle_get_lcp( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_MODIFY AND ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_REFERENCE.
        handle_get_modify_data( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS mv_software_component AND
        ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_CALL_METHOD.
        IF MV_IN_HELPER_CLASS = abap_true.
           CONTINUE.
        ENDIF.
        handle_get_helper_class( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_EXECUTE_ACTION
        AND ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_CALL_METHOD.
        handle_get_bo_action( EXPORTING in_current_line = ls_line_pool-line_num ).
     ENDIF.
  ENDLOOP.

endmethod.

method HANDLE_VARIABLE_EQUAL_NAME.
  DATA:   ls_item LIKE LINE OF lt_working_pool,
          lt_string TYPE string_table,
          lv_string TYPE string,
          lv_line TYPE string,
          lv_total TYPE i,
          length TYPE i,
          line_length TYPE i,
          lv_index TYPE i,
          lv_variable TYPE string,
          lv_type TYPE string,
          lv_attribute TYPE string,
          lt_result_table TYPE match_result_tab.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  FIND /SF0A0001/SCAN_CONSTANT=>C_REFER IN ls_item-line_text.
  CHECK sy-subrc <> 0.

  FIND /SF0A0001/SCAN_CONSTANT=>C_FIELD IN ls_item-line_text.
  CHECK sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  line_length = lines( lt_string ).
  CHECK line_length = 2.

  READ TABLE lt_string INTO lv_string INDEX 2.
  CONDENSE lv_string NO-GAPS.
  FIND ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_FIELD IN lv_string RESULTS lt_result_table.
  CHECK sy-subrc = 0.

  "TO BE ENHANCED in future to support multiple case
  IF lines( lt_result_table ) = 1.
    CLEAR: lt_string.
    SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_FIELD INTO TABLE lt_string.
    CHECK lines( lt_string ) = 2.
    READ TABLE lt_string INTO lv_variable INDEX 1.
    READ TABLE lt_string INTO lv_attribute INDEX 2.
    CALL METHOD get_variable_type
      EXPORTING
        in_name = lv_variable
      IMPORTING
        out_type = lv_type.
    CHECK lv_type IS NOT INITIAL.

    "CONCATENATE lv_type /SF0A0001/SCAN_CONSTANT=>C_FIELD lv_attribute INTO lv_attribute.
    CALL METHOD alpha_conversion
      EXPORTING
        in_name = lv_attribute
      IMPORTING
        out_name = lv_attribute.
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_attribute in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).
  ELSE.
    CLEAR: lt_string.
    SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_FIELD INTO TABLE lt_string.
    CHECK lines( lt_string ) > 2.
    READ TABLE lt_string INTO lv_variable INDEX 1.
    CALL METHOD get_variable_type
       EXPORTING
         in_name = lv_variable
       IMPORTING
         out_type = lv_type.
    CHECK lv_type IS NOT INITIAL.

    DELETE lt_string INDEX 1.
    CLEAR: lv_attribute.
    length = lines( lt_string ).
    LOOP AT lt_string  INTO lv_line.
      IF sy-tabix = length.
        lv_attribute = lv_attribute && '-' && lv_line.
      ELSE.
        lv_attribute = lv_attribute && lv_line.
      ENDIF.
    ENDLOOP.
    CALL METHOD alpha_conversion
      EXPORTING
        in_name = lv_attribute
      IMPORTING
        out_name = lv_attribute.
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_attribute in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).

  ENDIF.
endmethod.
method HANDLE_MOVE_CORRESPONDING.
  DATA:   ls_item LIKE LINE OF lt_working_pool,
          lt_string TYPE string_table,
          lv_string TYPE string,
          lv_line TYPE string,
          lv_total TYPE i,
          length TYPE i,
          line_length TYPE i,
          lv_index TYPE i,
          lv_variable TYPE string,
          lv_type TYPE string,
          lv_attribute TYPE string,
          lt_result_table TYPE match_result_tab.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.

  FIND /SF0A0001/SCAN_CONSTANT=>C_FIELD IN ls_item-line_text.
  CHECK sy-subrc = 0.

  FIND /SF0A0001/SCAN_CONSTANT=>C_TO IN ls_item-line_text.
  CHECK sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_TO INTO TABLE lt_string.
  line_length = lines( lt_string ).
  ASSERT line_length = 2.

  READ TABLE lt_string INTO lv_string INDEX 2.
  CONDENSE lv_string NO-GAPS.
  FIND ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_FIELD IN lv_string RESULTS lt_result_table.
  CHECK sy-subrc = 0.

  "TO BE ENHANCED in future to support multiple case
  IF lines( lt_result_table ) = 1.
    CLEAR: lt_string.
    SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_FIELD INTO TABLE lt_string.
    CHECK lines( lt_string ) = 2.
    READ TABLE lt_string INTO lv_variable INDEX 1.
    READ TABLE lt_string INTO lv_attribute INDEX 2.
    CALL METHOD get_variable_type
      EXPORTING
        in_name = lv_variable
      IMPORTING
        out_type = lv_type.
    CHECK lv_type IS NOT INITIAL.

    "CONCATENATE lv_type /SF0A0001/SCAN_CONSTANT=>C_FIELD lv_attribute INTO lv_attribute.
    CALL METHOD alpha_conversion
      EXPORTING
        in_name = lv_attribute
      IMPORTING
        out_name = lv_attribute.
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_attribute in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).
  ELSE.
    CLEAR: lt_string.
    SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_FIELD INTO TABLE lt_string.
    CHECK lines( lt_string ) > 2.
    READ TABLE lt_string INTO lv_variable INDEX 1.
    CALL METHOD get_variable_type
       EXPORTING
         in_name = lv_variable
       IMPORTING
         out_type = lv_type.
    CHECK lv_type IS NOT INITIAL.

    DELETE lt_string INDEX 1.
    CLEAR: lv_attribute.
    length = lines( lt_string ).
    LOOP AT lt_string  INTO lv_line.
      IF sy-tabix = length.
        lv_attribute = lv_attribute && '-' && lv_line.
      ELSE.
        lv_attribute = lv_attribute && lv_line.
      ENDIF.
    ENDLOOP.
    CALL METHOD alpha_conversion
      EXPORTING
        in_name = lv_attribute
      IMPORTING
        out_name = lv_attribute.
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_attribute in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).

  ENDIF.
endmethod.

method HANDLE_GET_MODIFY_DATA.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        line_length TYPE i,
        lv_index TYPE i.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  lv_string = /SF0A0001/SCAN_CONSTANT=>C_REFERENCE && /SF0A0001/SCAN_CONSTANT=>C_MODIFY.

  FIND lv_string IN ls_item-line_text.
  IF sy-subrc <> 0.
     lv_string = /SF0A0001/SCAN_CONSTANT=>C_WATER && /SF0A0001/SCAN_CONSTANT=>C_MODIFY.
     FIND lv_string IN ls_item-line_text.
     IF sy-subrc <> 0.
       RETURN.
     ENDIF.
  ENDIF.

  lv_total = lines( lt_working_pool ).
  lv_index = in_current_line.
  WHILE lv_index <= lv_total.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    line_length = strlen( ls_item-line_text ).
    IF line_length = 0.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    IF ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    CONDENSE ls_item-line_text.

    FIND /SF0A0001/SCAN_CONSTANT=>C_IN_MODIFICATIONS IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_item-line_text.
       IF sy-subrc = 0.
         FIND_real_modify_variable( EXPORTING in_current_line = ls_item-line_num ).
         RETURN.
       ENDIF.
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.
    ADD 1 TO lv_index.

  ENDWHILE.

endmethod.

method HANDLE_GET_HELPER_CLASS.

  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_result TYPE string,
        lv_total TYPE string,
        lv_helper_class TYPE string,
        lv_current TYPE i VALUE 2,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  lv_helper_class = get_helper_class_name( ls_item-line_text ).
  CHECK lv_helper_class IS NOT INITIAL.

  APPEND lv_helper_class TO mt_helper_class_Tab.
endmethod.

method HANDLE_GET_BO_ACTION.
  DATA:   ls_item LIKE LINE OF lt_working_pool,
          lt_string TYPE string_table,
          lv_string TYPE string,
          lv_total TYPE i,
          line_length TYPE i,
          lv_index TYPE i.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  lv_total = lines( lt_working_pool ).
  lv_index = in_current_line.
  WHILE lv_index <= lv_total.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    line_length = strlen( ls_item-line_text ).
    IF line_length = 0.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    IF ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    CONDENSE ls_item-line_text.

    FIND /SF0A0001/SCAN_CONSTANT=>C_BO_NODE_NAME IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_item-line_text.
       IF sy-subrc = 0.
         FIND_real_action_bo_name( EXPORTING in_current_line = ls_item-line_num ).
         ADD 1 TO lv_index.
         CONTINUE.
       ENDIF.
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_IN_ACTION_NAME IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND_REAL_ACTION_bo_NAME( EXPORTING in_current_line = ls_item-line_num ).
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
    IF sy-subrc = 0.
       RETURN.
    ENDIF.
    ADD 1 TO lv_index.

  ENDWHILE.
  ASSERt 1 = 0.
endmethod.

method HANDLE_EXIT_HELPER_CLASS.

  DATA: lv_class TYPE SEOCLSKEY,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method.

  DELETE ADJACENT DUPLICATES FROM mt_helper_class_tab.
  CLEAR: lv_exit_name.

  MV_IN_HELPER_CLASS = abap_true.

  LOOP AT mt_helper_class_tab INTO lv_badi_impl_name.
    lv_class-CLSNAME = lv_badi_impl_name.
  CALL FUNCTION 'SEO_METHOD_READ_ALL'
    EXPORTING
       CIFKEY  = lv_class
    IMPORTING
       methods = lt_method.

  LOOP AT lt_method INTO ls_method.
    CLEAR: method_key,lt_working_source.
    method_key-CLSNAME = lv_badi_impl_name.
    method_key-CPDNAME = ls_method-CMPname.
    CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
      EXPORTING
        MTDKEY = method_key
      IMPORTING
        SOURCE_expanded = lt_working_source.
    lv_current_method = ls_method-CMPname.

    FILL_SOURCE_TABLE( ).
    SCAN_BO_WRITE( ).
  ENDLOOP.

  ENDLOOP.
endmethod.

method HANDLE_EXECUTE_ACTION.
  DATA:   ls_item LIKE LINE OF lt_working_pool,
          lt_string TYPE string_table,
          lv_string TYPE string,
          lv_total TYPE i,
          line_length TYPE i,
          lv_index TYPE i.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  lv_total = lines( lt_working_pool ).
  lv_index = in_current_line.
  WHILE lv_index <= lv_total.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    line_length = strlen( ls_item-line_text ).
    IF line_length = 0.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    IF ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.
    CONDENSE ls_item-line_text.

    FIND /SF0A0001/SCAN_CONSTANT=>C_BO_NODE_NAME IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_item-line_text.
       IF sy-subrc = 0.
         FIND_real_action_bo_name( EXPORTING in_current_line = ls_item-line_num ).
         ADD 1 TO lv_index.
         CONTINUE.
       ENDIF.
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_IN_ACTION_NAME IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND_REAL_ACTION_NAME( EXPORTING in_current_line = ls_item-line_num ).
       ADD 1 TO lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
    IF sy-subrc = 0.
       RETURN.
    ENDIF.
    ADD 1 TO lv_index.

  ENDWHILE.
  ASSERt 1 = 0.
endmethod.

method HANDLE_EMBEDDED_CALL_METHOD.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lv_result TYPE string,
        lv_contain_lcp TYPE abap_bool VALUE abap_false,
        lv_count TYPE i,
        lt_MATCH_RESULT_TAB TYPE MATCH_RESULT_TAB,
        line1 TYPE match_result,
        line2 TYPE match_result,
        lv_off TYPE i,
        lv_len TYPE i,
        lv_variable_name TYPE string,
        lv_method_name TYPE string,
        lv_classname TYPE string,
        method_key TYPE SEOCPDKEY.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  FIND ALL OCCURRENCES OF '->' IN ls_item-line_text MATCH COUNT lv_count RESULTS lt_MATCH_RESULT_TAB.

  CHECK lv_count = 2.

  READ TABLE lt_match_result_tab INTO line1 INDEX 1.
  READ TABLE lt_match_result_tab INTO line2 INDEx 2.

  lv_off = line1-offset + 2.

  lv_len = line2-offset - lv_off.

  lv_variable_name = substring( val = ls_item-line_text off = lv_off len = lv_len ).
  CHECK lv_variable_name IS NOT INITIAL.

  lv_off = line2-offset + 2.
  lv_len = strlen( ls_item-line_text ) - lv_off.
  lv_method_name = ls_item-line_text+lv_off(lv_len).

  CHECK lv_method_name IS NOT INITIAL.

  CALL METHOD get_variable_type
    EXPORTING
      in_name = lv_variable_name
    IMPORTING
      out_type = lv_classname.

  CHECK lv_classname IS NOT INITIAL.

  method_key-CLSNAME = lv_classname.
  method_key-CPDNAME = lv_method_name.

  "backup currently working item
  DATA: lv_current_method_backup LIKE lv_current_method,
        lv_exit_name_backup LIKE lv_exit_name,
        lt_working_pool_backup LIKE lt_working_pool,
        lv_badi_impl_name_backup LIKE lv_badi_impl_name.

  CLEAR: lt_working_source.
  CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
      EXPORTING
        MTDKEY = method_key
      IMPORTING
        SOURCE_expanded = lt_working_source.

  lv_current_method = lv_method_name.
  lv_current_method_backup = lv_current_method.
  lv_exit_name_backup = lv_exit_name.
  lt_working_pool_backup = lt_working_pool.
  lv_badi_impl_name_backup = lv_badi_impl_name.
  lv_badi_impl_name = lv_classname.

  FILL_SOURCE_TABLE( ).
  SCAN_BO( ).

  lt_working_pool = lt_working_pool_backup.
  lv_exit_name = lv_exit_name_backup.
  lv_current_method = lv_current_method_backup.
  lv_badi_impl_name = lv_badi_impl_name_backup.
endmethod.

method GET_HELPER_CLASS_NAME.
  DATA: v1 TYPE i,
        v2 TYPE i,
        v3 TYPE i,
        lv_class TYPE SEOCLSKEY,
        lv_def TYPE seoclassdf.


  FIND mv_software_component in in_line_text MATCH OFFSET v1.
  CHECK sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_CALL_METHOD in in_line_text MATCH OFFSET v2.
  CHECK sy-subrc = 0.

  CHECK v2 > v1.
  v3 = v2 - v1 - 1.

  out_clasS_name = in_line_text+v1(v3).

  lv_class-clsname = out_class_name.

*  CALL FUNCTION 'SEO_CLASS_EXISTENCE_CHECK'
*    EXPORTING
*      CLSKEY = lv_class
*    EXCEPTIONS
*      NOT_SPECIFIED = 1
*      NOT_EXISTING = 2
*      IS_INTERFACE = 3
*      NO_TEXT = 4
*      INCONSISTENT = 5.
*  IF sy-subrc <> 0.
*    CLEAR: out_class_name.
*    RETURN.
*  ENDIF.

  SELECT SINGLE * FROM seoclassdf INTO lv_def WHERE clsname = out_class_name.
  IF sy-subrc <> 0.
     CLEAR: out_class_name.
     RETURN.
  ENDIF.

  IF lv_def-category = '40'.
     CLEAR: out_class_name.
     RETURN.
  ENDIF.




endmethod.

method FIND_REAL_MODIFY_VARIABLE.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        line_length TYPE i,
        lv_row TYPE string,
        lv_row_field TYPE string,
        lv_index TYPE i,
        ls_line TYPE ty_excel_line.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  line_length = lines( lt_string ).
  ASSERT line_length = 2.

  READ TABLE lt_string INTO lv_string INDEX 2.
  ASSERT lv_string IS NOT INITIAL.

  lv_index = in_current_line.
  WHILE lv_index > 0.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    ASSERT sy-subrc = 0.
    FIND lv_string IN ls_item-line_text.
    IF sy-subrc <> 0.
       SUBTRACT 1 FROM lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_TO IN ls_item-line_text.
    IF sy-subrc <> 0.
       SUBTRACT 1 FROM lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_APPEND IN ls_item-line_text.
    IF sy-subrc <> 0.
       FIND /SF0A0001/SCAN_CONSTANT=>C_INSERT IN ls_item-line_text.
       IF sy-subrc <> 0.
          SUBTRACT 1 FROM lv_index.
          CONTINUE.
       ENDIF.
    ENDIF.
    CLEAR: lt_string.
    CONDENSE ls_item-line_text.
    SPLIT ls_item-line_text AT SPACE INTO TABLE lt_string.
    ASSERT sy-subrc = 0.
    READ TABLE lt_string INTO lv_row INDEX 2.
    ASSERT lv_row IS NOT INITIAL.

    EXIT.
  ENDWHILE.

  ASSERT lv_row IS NOT INITIAL. "get row variable
  lv_row_field = lv_row && /SF0A0001/SCAN_CONSTANT=>C_FIELD.
  WHILE lv_index > 0. " get bo node name
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    ASSERT sy-subrc = 0.
    FIND lv_row_field IN ls_item-line_text.
    IF sy-subrc <> 0.
       SUBTRACT 1 FROM lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_MODIFY_BO_NODE IN ls_item-line_text.
    IF sy-subrc <> 0.
       SUBTRACT 1 FROM lv_index.
       CONTINUE.
    ENDIF.

    FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_item-line_text.
    IF sy-subrc <> 0.
       SUBTRACT 1 FROM lv_index.
       CONTINUE.
    ENDIF.

    CLEAR: lt_string.
    SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
    READ TABLE lt_string INTO lv_row INDEX 2.
    ASSERT lv_row IS NOT INITIAL.

    CLEAR: ls_line.
    ls_line-bo_name = lv_row.
    IF lv_exit_name IS NOT INITIAL.
       ls_line-bo_node_name = lv_exit_name && 'Line:' && lv_index.
    ELSE.
       ls_line-bo_node_name = lv_badi_impl_name && '_Method:' && lv_current_method && lv_index.
    ENDIF.
    APPEND ls_line TO lt_excel_tab.

    SUBTRACT 1 FROM lv_index.
  ENDWHILE.



endmethod.

method FIND_REAL_ACTION_NAME.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_2string TYPE string,
        lv_3string TYPE string,
        lv_string TYPE string,
        line_length TYPE i,
        ls_line TYPE ty_excel_line.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  line_length = lines( lt_string ).
  ASSERT line_length >= 2.
  IF line_length = 3.

     READ TABLE lt_string INTO lv_2string INDEX 2.
     ASSERT lv_2string IS NOT INITIAL.
     READ TABLE lt_string INTO lv_3string INDEX 3.
     ASSERT lv_3string IS NOT INITIAL.

     CONDENSE lv_2string NO-GAPS.
     CONDENSE lv_3string NO-GAPS.
     CONCATENATE lv_2string '=' lv_3string INTO lv_string.

     CALL METHOD interface2constant
       EXPORTING
          in_interface = lv_string
       IMPORTING
         out_constant = lv_string.

     record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ACTION_NAME ).
  ELSE.
     READ TABLE lt_string INTO lv_2string INDEX 2.
     ASSERT lv_2string IS NOT INITIAL.
     CALL METHOD alpha_conversion
       EXPORTING
         in_name = lv_2string
       IMPORTING
         out_name = lv_2string.
     record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_2string in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ACTION_NAME ).
  ENDIF.
endmethod.

method FIND_REAL_ACTION_BO_NAME.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        line_length TYPE i,
        ls_line TYPE ty_excel_line.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  line_length = lines( lt_string ).
  ASSERT line_length >= 2.

  READ TABLE lt_string INTO lv_string INDEX 2.
  ASSERT lv_string IS NOT INITIAL.

  CALL METHOD ALPHA_CONVERSION
     EXPORTING
         in_name = lv_string
     IMPORTING
         out_name = lv_string.

  record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).
endmethod.

method DO_SUMMARY.
  DATA: line LIKE LINE OF lt_bo_report_tab,
        lt_table LIKE lt_bo_report_tab.
  line-obj_name = 'Total'.  "#EC NOTEXT
  line-method_name = 'Click Here To Download As EXCEL'. "#EC NOTEXT
  APPEND line TO lt_bo_report_tab.

  lt_table = lt_bo_report_tab.

  SORT lt_table BY OBJ_NAME.
  DELETE ADJACENT DUPLICATES FROM lt_table COMPARING OBJ_NAME.
  line-obj_name = 'Total Badi Number:'. "#EC NOTEXT
  line-method_name = lines( lt_table ). "#EC NOTEXT
  APPEND line TO lt_bo_report_tab.

  CLEAR:lt_table.

  lt_table = lt_bo_report_tab.
  DELETE lt_table WHERE BO_ATTR_TYPE <> 'ROOT NAME'. "#EC NOTEXT  #EC CI_STDSEQ
  SORT lt_table BY BO_ATTR_NAME.
  DELETE ADJACENT DUPLICATES FROM lt_table COMPARING BO_ATTR_NAME.
  line-obj_name = 'Total Accessed BO Number:'. "#EC NOTEXT
  line-method_name = lines( lt_table ). "#EC NOTEXT
  APPEND line TO lt_bo_report_tab.

  CLEAR:lt_table.
  lt_table = lt_bo_report_tab.
  DELETE lt_table WHERE BO_ATTR_TYPE <> 'ASSOCIATION NAME'. "#EC NOTEXT  "#EC CI_STDSEQ
  SORT lt_table BY BO_ATTR_NAME.
  DELETE ADJACENT DUPLICATES FROM lt_table COMPARING BO_ATTR_NAME.
  line-obj_name = 'Total Used Association Number:'. "#EC NOTEXT
  line-method_name = lines( lt_table ). "#EC NOTEXT
  APPEND line TO lt_bo_report_tab.

  CLEAR:lt_table.
  lt_table = lt_bo_report_tab.
  DELETE lt_table WHERE BO_ATTR_TYPE <> 'BO FIELD NAME'. "#EC NOTEXT  "#EC CI_STDSEQ
  SORT lt_table BY BO_ATTR_NAME.
  DELETE ADJACENT DUPLICATES FROM lt_table COMPARING BO_ATTR_NAME.
  line-obj_name = 'Total Accessed BO Field Number:'. "#EC NOTEXT
  line-method_name = lines( lt_table ). "#EC NOTEXT
  APPEND line TO lt_bo_report_tab.


endmethod.

method _HANDLE_GET_QUERY_DATA.

  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_total TYPE i,
        lv_result TYPE string,
        lv_contain_lcp TYPE abap_bool VALUE abap_false.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  lv_total = lines( lt_string ).
  ASSERT lv_total > 0.
  READ TABLE lt_string INTO lv_result INDEX 2.
  ASSERT sy-subrc = 0.

  CALL METHOD ALPHA_CONVERSION
     EXPORTING
           in_name = lv_result
     IMPORTING
           out_name = lv_result.
  record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_result in_name_type = in_type ).
endmethod.

method HANDLE_GET_QUERY_DATA.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lv_result TYPE string,
        lv_contain_lcp TYPE abap_bool VALUE abap_false.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  LOOP AT lt_lcp_table INTO lv_result.
    FIND lv_result IN ls_item-line_text.
    IF sy-subrc = 0.
       lv_contain_lcp = abap_true.
       EXIT.
    ENDIF.
  ENDLOOP.

  CHECK lv_contain_lcp = abap_true.

  DATA: lt_string TYPE string_table,
        lv_index TYPE i,
        lv_max_line TYPE i,
        lv_total TYPE i,
        lv_current TYPE i,
        lv_string TYPE string.

  lv_max_line = lines( lt_working_pool ).
  lv_index = in_current_line + 1.
  WHILE lv_index < lv_max_line.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    IF ls_item-line_text CS /SF0A0001/SCAN_CONSTANT=>C_END.
       RETURN.
    ENDIF.
    IF ls_item-line_text CS /SF0A0001/SCAN_CONSTANT=>C_BO_NODE_NAME.
       _HANDLE_GET_QUERY_DATA( in_current_line = lv_index in_type = /SF0A0001/SCAN_CONSTANT=>C_BO_QUERY_NODE ).
    ELSEIF ls_item-line_text CS /SF0A0001/SCAN_CONSTANT=>C_IN_QUERY_NAME.
       _HANDLE_GET_QUERY_DATA( in_current_line = lv_index in_type = /SF0A0001/SCAN_CONSTANT=>C_BO_QUERY_NAME ).
    ENDIF.
    lv_index = lv_index + 1.
  ENDWHILE.

  ASSERT 1 = 0.

endmethod.

method EXCEL_HIGHLIGHT_NEEDED.
  out_result = SPACE.

  DATA: ref TYPE REF TO CL_ABAP_TYPEDESCR.
  ref = CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( in_value ).
  CHECK ref->TYPE_KIND <> ref->TYPEKIND_INT.
  CHECK in_value <> 'BO FIELD NAME'.

  FIND 'USED_ADDRESS' IN in_value.
  IF sy-subrc = 0.
    out_result = /SF0A0001/SCAN_CONSTANT=>C_USED_ADDRESS.
    RETURN.
  ENDIF.

  FIND 'ADDRESS' IN in_value.
  CHECK sy-subrc = 0.
  out_result = /SF0A0001/SCAN_CONSTANT=>C_ADDRESS.
endmethod.

method EXPORT.
  STATICS:lh_appl TYPE ole2_object,
          lh_workbook_list TYPE ole2_object,
          lh_workbook TYPE ole2_object,
          lh_sheet TYPE ole2_object,
          lh_columns TYPE ole2_object,
          lh_cell TYPE ole2_object,
          lh_interior TYPE ole2_object,
          lh_font TYPE ole2_object.

  DATA: lv_step TYPE string,
        lt_title TYPE string_table,
        ls_title TYPE string,
        lv_column TYPE i,
        lv_total_columns TYPE i,
        lv_row TYPE i.

  FIELD-SYMBOLS: <ls_excel_line> LIKE LINE OF lt_excel_tab,
                 <ls_itab_cell> TYPE string.

  lv_step = 'Starting Excel...'. "#EC NOTEXT
  log_with_text( lv_step ).

  CREATE OBJECT lh_appl 'Excel.Application' NO FLUSH. "#EC NOTEXT
  SET PROPERTY OF lh_appl 'SheetsInNewWorkbook' = 1 no flush. "#EC NOTEXT
  SET PROPERTY OF lh_appl 'Visible' = 0 . "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Create workbook...'. "#EC NOTEXT
  log_with_text( lv_step ).
       .
  GET PROPERTY OF lh_appl 'Workbooks' = lh_workbook_list no flush. "#EC NOTEXT
  CALL METHOD OF lh_workbook_list 'Add' = lh_workbook. "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Configure sheet...'. "#EC NOTEXT
  log_with_text( lv_step ).

  GET PROPERTY OF lh_appl 'ActiveSheet' = lh_sheet  no flush. "#EC NOTEXT
  SET PROPERTY OF lh_sheet 'Name' = 'BO'."#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Writing title...'. "#EC NOTEXT
  log_with_text( lv_step ).

  APPEND 'BO_NAME' TO lt_title. "#EC NOTEXT
  APPEND 'BO_NODE_NAME' TO lt_title. "#EC NOTEXT
  LOOP AT lt_title INTO ls_title.
    lv_column = sy-tabix.
    CALL METHOD OF lh_appl 'Cells' = lh_cell NO FLUSH   "#EC NOTEXT
      EXPORTING
      #1 = 1
      #2 = lv_column .
    ASSERT sy-subrc = 0.
    SET PROPERTY OF lh_cell 'Value' =  ls_title no flush. "#EC NOTEXT
    GET PROPERTY OF lh_cell 'Interior' = lh_interior no flush. "#EC NOTEXT
    SET PROPERTY OF lh_interior 'ColorIndex' = 35 no flush. "#EC NOTEXT
    GET PROPERTY OF lh_cell 'Font' = lh_font no flush. "#EC NOTEXT
    SET PROPERTY OF lh_font 'Bold' = 1 no flush. "#EC NOTEXT
  ENDLOOP.

  CALL FUNCTION 'FLUSH'  "Trigger the flush explicitly
    EXCEPTIONS
      cntl_system_error = 1
      cntl_error        = 2
      OTHERS            = 3.
  ASSERT sy-subrc = 0.

  lv_total_columns = lv_column.
  lv_row = 1.

  LOOP AT lt_excel_tab ASSIGNING <ls_excel_line>.
    lv_row = lv_row + 1.
    DO lv_total_columns TIMES.
      lv_column = sy-index.
      CALL METHOD OF lh_appl 'Cells' = lh_cell NO FLUSH "#EC NOTEXT
        EXPORTING
        #1 = lv_row
        #2 = lv_column.
      ASSERT sy-subrc = 0.
      ASSIGN COMPONENT lv_column OF STRUCTURE <ls_excel_line> TO <ls_itab_cell>.
      SET PROPERTY OF lh_cell 'Value' = <ls_itab_cell> no flush. "#EC NOTEXT
    ENDDO.
  ENDLOOP.

  CALL FUNCTION 'FLUSH'  "Trigger the flush explicitly
    EXCEPTIONS
      cntl_system_error = 1
      cntl_error        = 2
      OTHERS            = 3.
  ASSERT sy-subrc = 0.
       .
  CALL METHOD OF lh_sheet 'Columns' = lh_columns NO FLUSH. "#EC NOTEXT
  CALL METHOD OF lh_columns 'Autofit'. "#EC NOTEXT
  ASSERT sy-subrc = 0.

  lv_step = 'Saving and closing workbook...'. "#EC NOTEXT
  log_with_text( lv_step ).

  CALL METHOD OF lh_workbook 'SaveAs' NO FLUSH "#EC NOTEXT
    EXPORTING
    #1 = lv_excel_path. "File name

  CALL METHOD OF lh_workbook 'Close' NO FLUSH. "#EC NOTEXT
  CALL METHOD OF lh_appl 'Quit' NO FLUSH. "#EC NOTEXT
  FREE OBJECT lh_appl.
  IF sy-subrc <> 0.
    CONCATENATE 'Write back to:' lv_excel_path 'error,please close it first!' INTO lv_step
    SEPARATED BY SPACE."#EC NOTEXT
    MESSAGE lv_step TYPE 'E'.
  ENDIF.
endmethod.

method PREPARE_FOR_EXPORT.
  DATA: ls_item TYPE REF TO TY_EXCEL_LINE,
        ls_entry TYPE TY_EXCEL_LINE,
        lv_line TYPE string,
        lv_current TYPE string,
        lv_compare TYPE string,
        lt_string TYPE string_table.
  LOOP AT lt_excel_tab REFERENCE INTO ls_item.
    CHECK ls_item->bo_name IS INITIAL.
    FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item->bo_node_name.
    CHECK sy-subrc = 0.
    CLEAR: lt_string.
    SPLIT ls_item->bo_node_name AT /SF0A0001/SCAN_CONSTANT=>C_END INTO TABLE lt_string.
    CHECK lines( lt_string ) = 2.
    READ TABLE lt_string INTO ls_item->bo_name INDEX 1.
    ASSERT sy-subrc = 0.
    READ TABLE lt_string INTO ls_item->bo_node_name INDEX 2.
    ASSERT sy-subrc = 0.
  ENDLOOP.

  LOOP AT lt_excel_tab REFERENCE INTO ls_item.
    CHECK ls_item->bo_name IS NOT INITIAL.
    CHECK ls_item->bo_node_name IS INITIAL.
    ls_item->bo_node_name = /SF0A0001/SCAN_CONSTANT=>C_ROOT.
  ENDLOOP.

  DELETE lt_excel_Tab WHERE bo_name IS INITIAL.  "#EC CI_STDSEQ
  SORT lt_excel_tab BY BO_NAME BO_NODE_NAME DESCENDING.
  DELETE ADJACENT DUPLICATES FROM lt_excel_Tab COMPARING ALL FIELDS.

  READ TABLE lt_excel_tab REFERENCE INTO ls_item INDEX 1.
  ASSERT sy-subrc = 0.
  lv_compare = ls_item->bo_name.
  CLEAR: ls_entry.
  ls_entry-bo_node_name = '...'. "#EC NOTEXT
  LOOP AT lt_excel_tab REFERENCE INTO ls_item.
     IF lv_compare <> ls_item->bo_name.
        INSERT ls_entry INTO lt_excel_tab INDEX ( sy-tabix ).
        lv_compare = ls_item->bo_name.
     ENDIF.
  ENDLOOP.
endmethod.

method DISPLAY_EXPORT.
  DATA: gr_alv TYPE REF TO cl_salv_table,
        column_table TYPE REF TO CL_SALV_COLUMNS_TABLE,
        column TYPE REF TO CL_SALV_COLUMN,
        gr_selections TYPE REF TO cl_salv_selections,
        lx_alv_ex TYPE REF TO CX_SALV_MSG,
        lv_mesg TYPE string.

  IF lt_excel_tab IS INITIAL.
     RETURN.
  ENDIF.

  prepare_for_export( ).
  TRY.
    CALL METHOD cl_salv_table=>factory
      IMPORTING
        r_salv_table   = gr_alv
      CHANGING
        t_table        = lt_excel_tab.
    CATCH CX_SALV_MSG INTO lx_alv_ex.
       lv_mesg = lx_alv_ex->get_text( ).
       MESSAGE lv_mesg TYPE 'E'.
  ENDTRY.

  " Set up selections.
  gr_selections = gr_alv->get_selections( ).
  gr_selections->set_selection_mode( 1 ). "Single

  " Display
  column_table = gr_alv->GET_COLUMNS( ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'BO_NAME' ).
  column->SET_MEDIUM_TEXT( 'BO NAME' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'BO_NODE_NAME' ).
  column->SET_MEDIUM_TEXT( 'BO Node Name' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 50 ).

  EXPORT( ).
  CALL METHOD gr_alv->display.

endmethod.

method RECORD_EXCEL.
  DATA: ls_line TYPE ty_excel_line.

  CASE in_type.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_ROOT.
      ls_line-bo_name = in_line-bo_attr_name.
      APPEND ls_line TO lt_excel_tab.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_NODE.
      ls_line-bo_node_name = in_line-bo_attr_name.
      APPEND ls_line TO lt_excel_tab.
    WHEN OTHERS.
   ENDCASE.

endmethod.

method BUILD_PATH_BY_INTERFACE.
 DATA :"ls TYPE string value 'if_apcrm_opportunity=>co_bo_node-ROOT',
       lt TYPE string_table,
       lv_root TYPE string,
       lv_CO_BO_NAME TYPE string.

 FIELD-SYMBOLS : <bo> TYPE string,
                 <bo_node> TYPE string.

 FIND /SF0A0001/SCAN_CONSTANT=>C_REFER IN in_bo_attr_name.
 CHECK sy-subrc = 0.
 SPLIT in_bo_attr_name AT /SF0A0001/SCAN_CONSTANT=>C_REFER INTO TABLE lt.
 READ TABLE lt INTO lv_root INDEX 1.
 ASSERT sy-subrc = 0.
 lv_co_bo_name = lv_root && /SF0A0001/SCAN_CONSTANT=>C_REFER &&
   /SF0A0001/SCAN_CONSTANT=>C_CO_BO_NAME.

 ASSIGN (lv_co_bo_name) TO <bo>.
 CHECK sy-subrc = 0.
 ASSIGN (in_bo_attr_name) TO <bo_node>.
 CHECK sy-subrc = 0.

 out_bo_name = <bo> && /SF0A0001/SCAN_CONSTANT=>C_END && <bo_node>.

endmethod.

method TRY_FIND_LCP_VARIABLE.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_lcp TYPE string,
        lv_constant TYPE string,
        ls_lcp_map TYPE REF TO ty_lcp_map,
        ls_entry TYPE ty_lcp_map,
        lv_string TYPE string.

  " only search in the current line
  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  interface2constant( EXPORTING in_interface = in_bo_attr_name IMPORTING out_constant = lv_constant ).
  LOOP AT lt_lcp_table INTO lv_lcp.
    FIND lv_lcp IN ls_item-line_text.
    CHECK sy-subrc = 0.
    READ TABLE lt_lcp_map REFERENCE INTO ls_lcp_map WITH KEY lcp_name = lv_lcp.  "#EC CI_STDSEQ
    IF sy-subrc = 0.
       IF ls_lcp_map->bo_name <> in_bo_attr_name.
       " OVERWRITE: potential issue!
          ls_entry-lcp_name = lv_lcp.
          ls_entry-bo_name = lv_constant.
          APPEND ls_entry TO lt_lcp_map.
          RETURN.
       ENDIF.
    ELSE.
       ls_entry-lcp_name = lv_lcp.
       ls_entry-bo_name = lv_constant.
       APPEND ls_entry TO lt_lcp_map.
       RETURN.
    ENDIF.
  ENDLOOP.


endmethod.

method FILL_LCP_MAP_NEXT_LINE.

  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        lv_index TYPE i,
        lv_lcp TYPE string,
        lv_max_line TYPE i,
        ls_lcp_map TYPE ty_lcp_map,
        lv_constant TYPE string,
        line_length TYPE i.

  lv_max_line = /SF0A0001/SCAN_CONSTANT=>C_FIND_LCP_DOWN_LIMIT + in_current_line.
  lv_index = in_current_line.

  WHILE lv_index <= lv_max_line.
    READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
    ASSERT sy-subrc = 0.
    line_length = strlen( ls_line_pool-line_text ).
    IF line_length = 0.
       lv_index = lv_index + 1.
       CONTINUE.
    ENDIF.
    IF ls_line_pool-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR
       ls_line_pool-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       lv_index = lv_index + 1.
       CONTINUE.
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_OUT_LCP IN ls_line_pool-line_text.
    IF sy-subrc = 0.
      CONDENSE ls_line_pool-line_text.
      FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_line_pool-line_text.
      ASSERT sy-subrc = 0.
      DATA lt_temp TYPE string_table.
      SPLIT ls_line_pool-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_temp.
      READ TABLE lt_temp INTO lv_lcp INDEX 2.
      ASSERT sy-subrc = 0.
      alpha_conversion( EXPORTING in_name = lv_lcp IMPORTING out_name = lv_lcp ).
      interface2constant( EXPORTING in_interface = in_bo_attr_name IMPORTING out_constant = lv_constant ).
      ls_lcp_map-lcp_name = lv_lcp.
      ls_lcp_map-bo_name = lv_constant.
      APPEND ls_lcp_map TO lt_lcp_map.
      READ TABLE lt_temp INTO lv_lcp INDEX 1.
      ASSERT sy-subrc = 0.
    ENDIF.
    lv_index = lv_index + 1.

  ENDWHILE.

endmethod.

method FILL_LCP_TABLE.

  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        lv_tab_variable_define_line TYPE i,
        lv_result TYPE i,
        lv_index TYPE i,
        lt_temp TYPE string_table,
        lv_name TYPE string,
        line_length TYPE i.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     CONDENSE ls_line_pool-line_text.
     FIND /SF0A0001/SCAN_CONSTANT=>C_LCP_DEFINE IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/SCAN_CONSTANT=>C_FACADE IN ls_line_pool-line_text.
     CHECK sy-subrc <> 0.
     SPLIT ls_line_pool-line_text AT SPACE INTO TABLE lt_temp.
     lv_index = 1.
     LOOP AT lt_temp INTO lv_name.
       IF lv_name = /SF0A0001/SCAN_CONSTANT=>C_TYPE.
          READ TABLE lt_temp INTO lv_name INDEX ( lv_index - 1 ).
          ASSERT sy-subrc = 0.
          APPEND lv_name TO LT_LCP_TABLE.
          EXIT.
       ENDIF.
       lv_index = lv_index + 1.
     ENDLOOP.
     CLEAR: lt_temp.
  ENDLOOP.

  SORT lt_lcp_table.
endmethod.

method INTERFACE2CONSTANT.
  FIELD-SYMBOLS: <lv_string> TYPE string.

  DATA: lt_string TYPE string_table,
        lv_result TYPE string.
  FIND /SF0A0001/SCAN_CONSTANT=>C_REFER IN in_interface.
  IF sy-subrc <> 0.
     out_constant = in_interface.
     RETURN.
  ENDIF.

  ASSIGN (in_interface) TO <lv_string>.
  IF sy-subrc = 0.
     out_constant = <lv_string>.
     RETURN.
  ELSE.
     SPLIT in_interface AT 'AND' INTO TABLE lt_string.
     ASSERT sy-subrc = 0.
     READ TABLE lt_string INTO lv_result INDEX 1.
     ASSERT sy-subrc = 0.
     ASSIGN (lv_result) TO <lv_string>.
     ASSERT sy-subrc = 0.
     out_constant = <lv_string>.
  ENDIF.
endmethod.

method UP_CHECK_IN_BO_NAME.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lv_current_index TYPE i,
        lv_bo_name TYPE string,
        lt_temp TYPE string_table,
        lv_up_limit TYPE i.

  lv_current_index = in_current_line.
  lv_up_limit = lv_current_index - /SF0A0001/SCAN_CONSTANT=>C_FIND_LCP_UP_LIMIT.

  WHILE lv_current_index >= lv_up_limit.
    READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_current_index.
    ASSERT sy-subrc = 0.
    line_length = strlen( ls_line_pool-line_text ).
    IF line_length <= 0.
       lv_current_index = lv_current_index - 1.
       CONTINUE.
    ENDIF.
    IF ls_line_pool-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR
       ls_line_pool-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       lv_current_index = lv_current_index - 1.
       CONTINUE.
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_BO_NAME IN ls_line_pool-line_text.
    IF sy-subrc = 0.
       CONDENSE ls_line_pool-line_text.
       SPLIT ls_line_pool-line_text AT SPACE INTO TABLE lt_temp.
       READ TABLE lt_temp INTO lv_bo_name INDEX 3.
       ASSERT sy-subrc = 0.
       interface2constant( EXPORTING in_interface = lv_bo_name IMPORTING out_constant = out_bo_name ).
       alpha_conversion( EXPORTING in_name = out_bo_name IMPORTING out_name = out_bo_name ).
       RETURN.
    ENDIF.
    lv_current_index = lv_current_index - 1.
  ENDWHILE.


endmethod.

method POPULATE_WHOLE_PATH.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lv_full_path TYPE string,
        lv_constant TYPE string,
        lv_current_index TYPE i,
        ls_map LIKE LINE OF lt_lcp_map,
        lv_up_line TYPE i,
        line_length TYPE i,
        lv_bo_name TYPE string,
        lv_lcp TYPE string,
        lv_string TYPE string.

  lv_current_index = in_current_line.
  lv_up_line = lv_current_index - /SF0A0001/SCAN_CONSTANT=>C_FIND_LCP_UP_LIMIT.
  interface2constant( EXPORTING in_interface = in_bo_attr_name IMPORTING out_constant = lv_constant ).

  WHILE lv_current_index >= lv_up_line.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_current_index.
    IF sy-subrc <> 0.
       RETURN.
    ENDIF.
    line_length = strlen( ls_item-line_text ).
    IF line_length <= 0.
       lv_current_index = lv_current_index - 1.
       CONTINUE.
    ENDIF.
    IF ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR
       ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
       lv_current_index = lv_current_index - 1.
       CONTINUE.
    ENDIF.
    CLEAR: lv_lcp.
    get_lcp_in_source( EXPORTING in_source_code = ls_item-line_text IMPORTING out_lcp_name = lv_lcp ).
    IF lv_lcp IS NOT INITIAL.
       " found LCP
       READ TABLE lt_lcp_map INTO ls_map WITH TABLE KEY lcp_name = lv_lcp.  "#EC CI_STDSEQ
       IF sy-subrc <> 0.
         EXIT.
       ENDIF.
       out_whole_path = ls_map-BO_name && /SF0A0001/SCAN_CONSTANT=>C_END && lv_constant.
       RETURN.
    ENDIF.
    lv_current_index = lv_current_index - 1.
  ENDWHILE.

  "the last step: move a line up to check "  IN_BO_NAME    "
  up_check_in_bo_name( EXPORTING in_current_line = in_current_line IMPORTING out_bo_name = lv_bo_name ).
  IF lv_bo_name IS NOT INITIAL.
     out_whole_path = lv_bo_name && /SF0A0001/SCAN_CONSTANT=>C_END && lv_constant.
  ELSE. " IF_APCRM_OPPORTUNITY=>CO_BO_NODE-ROOT
     build_path_by_interface( EXPORTING in_bo_attr_name = in_bo_attr_name IMPORTING out_bo_name = lv_bo_name ).
     IF lv_bo_name IS NOT INITIAL.
        out_whole_path = lv_bo_name.
     ENDIF.
  ENDIF.
endmethod.

method GET_LCP_IN_SOURCE.
  DATA : lv_lcp TYPE string.

  LOOP AT lt_lcp_table INTO lv_lcp.
     FIND lv_lcp IN in_source_code.
     IF sy-subrc = 0.
        out_lcp_name = lv_lcp.
        RETURN.
     ENDIF.
  ENDLOOP.
endmethod.

method LOG_WITH_TEXT.
     CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = in_text.
endmethod.

method EXTRACT_STRU_FROM_DIFF_TAB.

  " find struct name
  DATA:
        ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_index TYPE i,
        lv_find_end TYPE i VALUE 0,
        line_length TYPE i,
        lv_max_line TYPE i.

  "concatenate source code
  lv_index = in_current_line.
  lv_max_line = lines( lt_working_pool ).

  WHILE lv_index < lv_max_line.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    line_length = strlen( ls_item-line_text ).
     IF line_length = 0 OR ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT
        OR ls_item-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
        lv_index = lv_index + 1.
        CONTINUE.
     ENDIF.
     CONCATENATE lv_string ls_item-line_text INTO lv_string SEPARATED BY SPACE.
     FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
     IF sy-subrc = 0.
        lv_find_end = 1.
        EXIT.
     ENDIF.
     lv_index = lv_index + 1.
  ENDWHILE.

  ASSERT lv_find_end = 1.
  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  DATA:
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_temp TYPE string,
        lv_filter TYPE string,
        lv_subtotal TYPE i.

  lv_total = strlen( lv_string ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_INTO IN lv_string.
  IF sy-subrc <> 0.
     FIND /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING IN lv_string.
     " ASSERT sy-subrc = 0.
     " READ TABLE LT_BPVT TRANSPORTING NO FIELDS WITH KEY ROOT_KEY = LS_KEY-KEY.
     IF sy-subrc <> 0 .
        RETURN.
     ENDIF.
     lv_filter = /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING.
  ELSE.
     lv_filter = /SF0A0001/SCAN_CONSTANT=>C_INTO.
  ENDIF.

  FIND lv_filter IN lv_string MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.
  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = lv_string+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_temp.
    CHECK lv_temp <> SPACE.
    alpha_conversion( EXPORTING in_name = lv_temp IMPORTING out_name = lv_temp ).
    APPEND lv_temp TO lt_struct_tab.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.
endmethod.

method FILL_POST_EXIT_WORKING_POOL.
  DATA: lv_enh_name2 TYPE char256,
        lv_enh_name TYPE ENHNAME,
        itab TYPE string_table,
        ls_source TYPE string,
        ls_line LIKE LINE OF lt_working_pool.

  SELECT enhname FROM enhsort INTO lv_enh_name2 WHERE version = 'A' AND ENHNAME = lv_badi_impl_name.
  ASSERT sy-subrc = 0.
  ENDSELECT.

  lv_enh_name = lv_badi_impl_name.
  TRANSLATE lv_enh_name TO UPPER CASE.
  mv_software_component = lv_enh_name+0(10).
  TRANSLATE lv_enh_name USING ' ='.
  CONCATENATE lv_enh_name 'EIMP' INTO lv_enh_name2.
  lv_exit_name = lv_enh_name2.
  READ REPORT lv_enh_name2 INTO itab.

  LOOP AT itab INTO ls_source.
     ls_line-line_num = sy-tabix.
     ls_line-line_text = ls_source.
     TRANSLATE ls_line-line_text TO UPPER CASE.
     APPEND ls_line TO lt_working_pool.
     CLEAR: ls_line.
  ENDLOOP.

endmethod.

method GET_IMPL_CLASS_NAME.
  DATA: lo_enh_impl TYPE REF TO if_enh_tool,
        lo_badi_impl_tool TYPE REF TO cl_enh_tool_badi_impl,
        lx_badi_impl_error TYPE REF TO CX_ENH_BADI_IMPL_NOT_VALID,
        lx_io_error TYPE REF TO CX_ENH_IO_ERROR,
        lv_error TYPE string,
        lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        ex_badi_info TYPE ENH_BADI_IMPL_DATA.

  TRY.
    lo_enh_impl = cl_enh_factory=>get_enhancement(
          enhancement_id         = in_enh_name ).
    CATCH CX_ENH_IO_ERROR into lx_io_error.
       lv_error = lx_io_error->get_text( ).
       RETURN.
    CATCH CX_ENH_IS_NOT_MODIFIABLE.
       RAISE EXCEPTION TYPE CX_FATAL_EXCEPTION.
  ENDTRY.

  lo_badi_impl_tool ?= lo_enh_impl.
  " bug reported by Yoyo on 2009/04/08: impl must be used instead of enh name
  SELECT ENHNAME ACTIVE BADI_IMPL FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME = in_enh_name.
  IF lines( lt_badi_table ) <> 1.
     RETURN.
  ENDIF.
  READ TABLE lt_badi_table INTO ls_badi INDEX 1.
  ASSERT sy-subrc = 0.

  TRY.
     CALL METHOD lo_badi_impl_tool->GET_IMPLEMENTATION
       EXPORTING
          IMPL_NAME         = ls_badi-BADI_IMPL
       RECEIVING
          RE_IMPLEMENTATION = ex_badi_info.

  CATCH CX_ENH_BADI_IMPL_NOT_VALID into lx_badi_impl_error.
    lv_error = lx_badi_impl_error->get_text( ).
    ASSERT 1 = 0.
  ENDTRY.

  IF ex_badi_info IS INITIAL.
     ASSERT 1 = 0.
  ENDIF.

  lv_badi_impl_name = ex_badi_info-IMPL_CLASS.
endmethod.

method HANDLE_OBJ_NOT_IN_TAB.
  " TO BE ENHANCED IN THE FUTURE
endmethod.

method HANDLE_OBJ_NOT_IN_TAB.
  " TO BE ENHANCED IN THE FUTURE
endmethod.
method EXTRACT_OUTPUT_DATA.
   DATA:
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_result TYPE string,
        ls_variable_line TYPE ty_variable_line,
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_subtotal TYPE i.

  lv_total = strlen( in_source_code ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN in_source_code
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.
  IF sy-subrc <> 0 .
     RETURN.
  ENDIF.
  lv_offset = lv_offset + 1.
  lv_subtotal = lv_total - lv_offset.
  lv_string = in_source_code+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_result.
     CHECK lv_result <> SPACE.
     alpha_conversion( EXPORTING in_name = lv_result IMPORTING out_name = lv_result ).
     ls_variable_line-variable_name = lv_result.
     APPEND ls_variable_line TO lt_outdata_tab.
     EXIT.
  ENDLOOP.
  extract_output_data( EXPORTING in_source_code = lv_string ).

endmethod.

method HANDLE_GET_IMPORT_DATA.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_index TYPE i,
        lv_max TYPE i,
        lv_string TYPE string.

  lv_index = in_current_line.
  lv_max = lines( lt_working_pool ).
  WHILE lv_index <= lv_max.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    ASSERT sy-subrc = 0.
    FIND /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN ls_item-line_text.
    IF sy-subrc = 0. " IMPORT a = b c = d e = f ).
       extract_output_data( EXPORTING in_source_code = ls_item-line_text ).
    ENDIF.
    FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
    IF sy-subrc = 0.
       RETURN.
    ENDIF.
    lv_index = lv_index + 1.
  ENDWHILE.
  ASSERT 1 = 0.
endmethod.

method RETRIEVE_BO_ATTR_FROM_STRU.
   DATA: ls_item LIKE LINE OF lt_working_pool,
         line_length TYPE i,
         lv_total TYPE i,
         lt_string TYPE string_table,
         lv_subtotal TYPE i,
         lv_offset TYPE i,
         lv_match_len TYPE i,
         lv_filter TYPE string,
         lv_result TYPE string,
         lv_type TYPE string,
         lv_bo_attr TYPE string,
         lv_find TYPE string.

   lv_filter = in_stru_name && /SF0A0001/SCAN_CONSTANT=>C_FIELD.
   LOOP AT lt_working_pool INTO ls_item.
     line_length = strlen( ls_item-line_text ).
     CHECK line_length > 0.
     CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
     CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     FIND lv_filter IN ls_item-line_text MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.
     CHECK sy-subrc = 0.
     lv_total = strlen( ls_item-line_text ).
     lv_offset = lv_offset + lv_match_len.
     lv_subtotal = lv_total - lv_offset.
     lv_find = ls_item-line_text+lv_offset(lv_subtotal).
     SPLIT lv_find AT SPACE INTO TABLE lt_string.
     LOOP AT lt_string INTO lv_result.
         CHECK lv_result <> SPACE.
         get_variable_type( EXPORTING in_name = in_stru_name IMPORTING out_type = lv_type ).
         alpha_conversion( EXPORTING in_name = lv_result IMPORTING out_name = lv_result ).
         CLEAR: lv_bo_attr.
         lv_bo_attr = lv_type && /SF0A0001/SCAN_CONSTANT=>C_FIELD && lv_result.
         RECORD( EXPORTING in_current_line = ls_item-line_num in_bo_attr_name = lv_bo_attr in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_FIELD ).
         "WRITE:/ 'Current Method:' , lv_current_method.
         "WRITE:/ ls_item-line_num, 'STRUCT ATTRIBUTE:' , lv_result, 'TYPE:' , lv_type, 'code:',ls_item-line_num.
         EXIT.
     ENDLOOP.
   ENDLOOP.
endmethod.

method HANDLE_STRUC_TABLE.
  DATA: lv_item TYPE string.
  SORT lt_struct_tab.
  DELETE ADJACENT DUPLICATES FROM lt_struct_tab.
  LOOP AT lt_struct_tab INTO lv_item.
    retrieve_bo_attr_from_stru( EXPORTING in_stru_name = lv_item ).
  ENDLOOP.
endmethod.

method EXTRACT_STRU_FROM_LOOP_AT_INTO.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_subtotal TYPE i.

  lv_total = strlen( in_source_code ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_INTO  IN in_source_code
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.

  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = in_source_code+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_string.
    CHECK lv_string <> SPACE.
    alpha_conversion( EXPORTING in_name = lv_string IMPORTING out_name = lv_string ).
    APPEND lv_string TO lt_struct_tab.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.
endmethod.

method EXTRACT_STRU_FROM_LOOP_AT_ASSI.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_subtotal TYPE i.

  lv_total = strlen( in_source_code ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING  IN in_source_code
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.

  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = in_source_code+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_string.
    CHECK lv_string <> SPACE.
    alpha_conversion( EXPORTING in_name = lv_string IMPORTING out_name = lv_string ).
    APPEND lv_string TO lt_struct_tab.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.
endmethod.

method EXTRACT_STRU_FROM_LOOP_AT_ASSI.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_subtotal TYPE i.

  lv_total = strlen( in_source_code ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING  IN in_source_code
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.

  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = in_source_code+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_string.
    CHECK lv_string <> SPACE.
    alpha_conversion( EXPORTING in_name = lv_string IMPORTING out_name = lv_string ).
    APPEND lv_string TO lt_struct_tab.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.
endmethod.

method HANDLE_LOOP_AT.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_WHERE IN ls_item-line_text.
  IF sy-subrc = 0.
     CALL METHOD get_bo_attr_from_loop_at_where
        EXPORTING
          in_name = in_name
          in_type = in_type
          in_current_line = in_current_line.
  ENDIF.
  " only INTO OR ASSIGNING possoble!
  FIND /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING IN ls_item-line_text.
  IF sy-subrc = 0.
       extract_stru_from_loop_at_assi( EXPORTING in_source_code = ls_item-line_text ).
  ELSE.
       FIND /SF0A0001/SCAN_CONSTANT=>C_INTO IN ls_item-line_text.
       ASSERT sy-subrc = 0.
       extract_stru_from_loop_at_into( EXPORTING in_source_code = ls_item-line_text ).
  ENDIF.

endmethod.

method HANDLE_READ_TABLE.
  DATA:   "    READ TABLE lt_text_coll_id INTO ls_text_coll_id INDEX 1..
        ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_TABLE_KEY IN ls_item-line_text.
  IF sy-subrc = 0."table key may be missed in case of READ and WITH KEY are in different line
     CALL METHOD get_bo_attr_from_with_key
        EXPORTING
          in_name = in_name
          in_type = in_type
          in_current_line = in_current_line.
  ENDIF.
  " only INTO OR ASSIGNING possoble!
  " may not in the same line!
  FIND /SF0A0001/SCAN_CONSTANT=>C_ASSIGNING IN ls_item-line_text.
  IF sy-subrc = 0.
     extract_stru_from_loop_at_assi( EXPORTING in_source_code = ls_item-line_text ).
  ELSE.
     FIND /SF0A0001/SCAN_CONSTANT=>C_INTO IN ls_item-line_text.
     IF sy-subrc = 0.
        extract_stru_from_loop_at_into( EXPORTING in_source_code = ls_item-line_text ).
     ELSE.
       " READ and ASSIGNING/INTO is not in the same line, don't know why developer likes this!!
       CALL METHOD EXTRACT_STRU_FROM_DIFF_TAB
          EXPORTING
            in_name = in_name
            in_type = in_type
            in_current_line = in_current_line.
     ENDIF.
  ENDIF.

endmethod.

method GET_BO_ATTR_FROM_LOOP_AT_WHERE.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_total TYPE i,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_bo_attr TYPE string,
        lv_subtotal TYPE i.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  lv_total = strlen( ls_item-line_text ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_WHERE  IN ls_item-line_text
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.

  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = ls_item-line_text+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_string.
    CHECK lv_string <> SPACE.
    CLEAR: lv_bo_attr.
    IF in_type IS NOT INITIAL.
       lv_bo_attr = in_type && /SF0A0001/SCAN_CONSTANT=>C_FIELD && lv_string.
    ELSE.
       lv_bo_attr = in_name && /SF0A0001/SCAN_CONSTANT=>C_FIELD && lv_string.
    ENDIF.
    RECORD( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_bo_attr in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_FIELD ).
    "WRITE:/ 'Current Method:' , lv_current_method.
    "WRITE:/ 'Table Key' , lv_string , 'table Name:' , in_name, 'code: ' , in_current_line.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.

endmethod.

method GET_BO_ATTR_FROM_WITH_KEY.
  DATA:   " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
        ls_item LIKE LINE OF lt_working_pool,
        ls_next LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_line TYPE string,
        lv_total TYPE i,
        lv_bo_attr TYPE string,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_length TYPE i,
        lv_index TYPE i VALUE 1,
        lv_subtotal TYPE i.

  "       READ TABLE LT_DATA_ACL_ROOT ASSIGNING <FS_ACL_ROOT> WITH KEY
  "         PARENT_NODE_ID = <FS_CUSTOMER_COM>-PARENT_NODE_ID.
  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
  lv_line = ls_item-line_text.
  IF sy-subrc <> 0.
    DO /SF0A0001/SCAN_CONSTANT=>C_FIND_LCP_DOWN_LIMIT TIMES.
      READ TABLE lt_working_pool INTO ls_next INDEX ( in_current_line + lv_index ).
      ASSERT sy-subrc = 0.
      lv_length = strlen( ls_next-line_text ).
      IF lv_length = 0.
         lv_index = lv_index + 1.
         CONTINUE.
      ENDIF.
      IF ls_next-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT OR
         ls_next-line_text+0(1) = /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
         lv_index = lv_index + 1.
         CONTINUE.
      ENDIF.
      lv_line = lv_line && ls_next-line_text.
      FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_item-line_text.
      IF sy-subrc = 0.
         EXIT.
      ENDIF.
      lv_index = lv_index + 1.
    ENDDO.
  ENDIF.
  CONDENSE lv_line.
  lv_total = strlen( lv_line ).
  FIND /SF0A0001/SCAN_CONSTANT=>C_TABLE_KEY  IN lv_line
    MATCH LENGTH lv_match_len MATCH OFFSET lv_offset.

  lv_offset = lv_offset + lv_match_len.
  lv_subtotal = lv_total - lv_offset.
  lv_string = lv_line+lv_offset(lv_subtotal).
  SPLIT lv_string AT SPACE INTO TABLE lt_string.
  LOOP AT lt_string INTO lv_string.
    CHECK lv_string <> SPACE.
    CLEAR: lv_bo_attr.
    IF in_type IS NOT INITIAL.
       lv_bo_attr = in_type && /SF0A0001/SCAN_CONSTANT=>C_FIELD && lv_string.
    ELSE.
       lv_bo_attr = in_name && /SF0A0001/SCAN_CONSTANT=>C_FIELD && lv_string.
    ENDIF.
    RECORD( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_bo_attr in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_FIELD ).
    " WRITE:/ 'Current Method:' , lv_current_method.
    " WRITE:/ 'Table Key' , lv_string , 'table Name:' , in_name, 'code: ' , in_current_line.
    RETURN.
  ENDLOOP.
  ASSERT 1 = 0.

endmethod.

method GET_VARIABLE_TYPE.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        line_length TYPE i,
        lv_string TYPE string,
        lv_match_len TYPE i,
        lv_offset TYPE i,
        lv_postfix TYPE c,
        lv_inner_index TYPE i,
        lv_string_next TYPE string,
        lt_condense TYPE string_table.

  LOOP AT lt_working_pool INTO ls_item.
     CLEAR: lv_match_len, lv_offset,lv_postfix.
     line_length = strlen( ls_item-line_text ).
     CHECK line_length > 0.
     CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
     CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     FIND in_name IN ls_item-line_text MATCH OFFSET lv_offset MATCH LENGTH lv_match_len.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/SCAN_CONSTANT=>C_TYPE IN ls_item-line_text.
     CHECK sy-subrc = 0.
     " TO BE HANDLED IN THE FUTURE : LIKE SCENARIO
     " TO BE CORRECTED:  TYPE if_addr_form_address_map_types=>tt_form_address,
     lv_offset = lv_offset + lv_match_len.
     CHECK lv_offset <> line_length.
     lv_postfix = ls_item-line_text+lv_offset(1).
     CHECK lv_postfix = SPACE.
     CLEAR: lt_string,lt_condense.
     SPLIT ls_item-line_text AT SPACE INTO TABLE lt_string.
     IF lt_string IS INITIAL.
        CONTINUE.
     ENDIF.
     LOOP AT lt_string INTO lv_string.
        CHECK lv_string <> SPACE.
        APPEND lv_string TO lt_condense.
     ENDLOOP.
     IF lt_condense IS INITIAL.
        CONTINUE.
     ENDIF.
     lv_inner_index = 1.
     LOOP AT lt_condense INTO lv_string.
       IF lv_string = /SF0A0001/SCAN_CONSTANT=>C_TYPE.
         READ TABLE lt_condense INTO lv_string INDEX ( lv_inner_index + 1 ).
         ASSERT sy-subrc = 0.
         READ TABLE lt_condense INTO lv_string_next INDEX ( lv_inner_index + 2 ).
         IF sy-subrc <> 0.
            EXIT.
         ENDIF.
         IF lv_string_next = /SF0A0001/SCAN_CONSTANT=>C_TO AND lv_string = /SF0A0001/SCAN_CONSTANT=>C_REF.
            READ TABLE lt_condense INTO lv_string INDEX ( lv_inner_index + 3 ).
            ASSERT sy-subrc = 0.
         ENDIF.
         EXIT.
       ENDIF.
       lv_inner_index = lv_inner_index + 1.
     ENDLOOP.
     alpha_conversion( EXPORTING in_name = lv_string IMPORTING out_name = out_type ).
     RETURN.
  ENDLOOP.
endmethod.

method RETRIEVE_BO_ATTR_FROM_TAB.

  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string,
        lv_filter TYPE string,
        line_length TYPE i.

  FIELD-SYMBOLS: <ls_item> TYPE ty_variable_line.

  SORT lt_outdata_tab BY variable_name.
  DELETE ADJACENT DUPLICATES FROM lt_outdata_tab.
  LOOP AT lt_outdata_tab ASSIGNING <ls_item>.
     CALL METHOD get_variable_type
       EXPORTING
         in_name = <ls_item>-variable_name
       IMPORTING
         out_type = <ls_item>-variable_type.
     " for formal parameter, its type can not be retrieved in
     " the source code of method itself
     " TO DO
     "ASSERT <ls_item>-variable_type IS NOT INITIAL.

     LOOP AT lt_working_pool INTO ls_item.
         line_length = strlen( ls_item-line_text ).
         CHECK line_length > 0.
         CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
         CHECK ls_item-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
         FIND <ls_item>-variable_name IN ls_item-line_text.
         CHECK sy-subrc = 0.
         " filter different scenarios here
         " LOOP AT lt_text INTO ls_text WHERE type_code-content = '10024'.
         FIND /SF0A0001/SCAN_CONSTANT=>C_LOOP_AT IN ls_item-line_text.
         IF sy-subrc = 0.
            CALL METHOD HANDLE_LOOP_AT
              EXPORTING
                in_name = <ls_item>-variable_name
                in_type = <ls_item>-variable_type
                in_current_line = ls_item-line_num.
         ELSE.
           FIND /SF0A0001/SCAN_CONSTANT=>C_READ_TABLE IN ls_item-line_text.
           IF sy-subrc = 0.
             CALL METHOD HANDLE_READ_TABLE
               EXPORTING
                in_name = <ls_item>-variable_name
                in_type = <ls_item>-variable_type
                in_current_line = ls_item-line_num.
           ENDIF.
         ENDIF.
         " it is possible that variable is not TABLE type
*         CLEAR: lv_filter.
*         lv_filter = <ls_item>-variable_name && /SF0A0001/SCAN_CONSTANT=>C_FIELD.
*         FIND lv_filter IN ls_item-line_text.
*         IF sy-subrc = 0.
*           "BREAK-POINT.
*           CALL METHOD HANDLE_OBJ_NOT_IN_TAB
*             EXPORTING
*               in_name = <ls_item>-variable_name
*               in_type = <ls_item>-variable_type
*               in_current_line = ls_item-line_num.
*         ENDIF.
     ENDLOOP.
  ENDLOOP.

  " handle_with_struc_table
  handle_struc_table( ).
endmethod.

method DISPLAY.
  DATA: gr_alv TYPE REF TO cl_salv_table,
        column_table TYPE REF TO CL_SALV_COLUMNS_TABLE,
        column TYPE REF TO CL_SALV_COLUMN,
        gr_selections TYPE REF TO cl_salv_selections,
        gr_events TYPE REF TO cl_salv_events_table,
        lx_alv_ex TYPE REF TO CX_SALV_MSG,
        gv_functions TYPE REF TO CL_SALV_FUNCTIONS_LIST,
        lo_event_handler TYPE REF TO /SF0A0001/CI_BO_NAME_HANDLER,
        lv_mesg TYPE string,
        lr_functions TYPE REF TO CL_SALV_FUNCTIONS_LIST.

  IF lt_bo_report_tab IS INITIAL.
     RETURN.
  ENDIF.

  IF lv_work_mode = /SF0A0001/SCAN_CONSTANT=>C_MASS.
     do_summary( ).
  ENDIF.

  TRY.
    CALL METHOD cl_salv_table=>factory
      IMPORTING
        r_salv_table   = gr_alv
      CHANGING
        t_table        = lt_bo_report_tab.


  gr_events = gr_alv->get_event( ).
  CREATE OBJECT lo_event_handler.
  lo_event_handler->init( EXPORTING in_report_table = lt_bo_report_tab in_work_mode = lv_work_mode ).
  SET HANDLER lo_event_handler->on_double_click FOR gr_events.

  " Set up selections.
  gr_selections = gr_alv->get_selections( ).
  gr_selections->set_selection_mode( IF_SALV_C_SELECTION_MODE=>MULTIPLE ). "Single
  " Display
  column_table = gr_alv->GET_COLUMNS( ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'OBJ_NAME' ).
  column->SET_MEDIUM_TEXT( 'Badi/PostExit' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'METHOD_NAME' ).
  column->SET_MEDIUM_TEXT( 'Method Name' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).
  IF lv_work_mode = /SF0A0001/SCAN_CONSTANT=>C_EXIT.
    column->SET_VISIBLE( SPACE ).
  ENDIF.

  column = column_table->GET_COLUMN( COLUMNNAME = 'ICON' ).
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 2 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'BO_ATTR_TYPE' ).
  column->SET_MEDIUM_TEXT( 'Name Type' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 20 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'BO_ATTR_NAME' ).
  column->SET_MEDIUM_TEXT( 'Proxy Name' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 50 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'LINE_NUM' ).
  column->SET_MEDIUM_TEXT( 'Line' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 4 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'LINE_TEXT' ).
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 70 ).
  column->SET_MEDIUM_TEXT( 'Source Code' ). "#EC NOTEXT

  lr_functions = gr_alv->get_functions( ).
  lr_functions->set_all( abap_true ).

  CALL METHOD gr_alv->display.

  CATCH CX_SALV_MSG INTO lx_alv_ex.
       lv_mesg = lx_alv_ex->get_text( ).
       MESSAGE lv_mesg TYPE 'E'.
  CATCH CX_SALV_NOT_FOUND.
     RAISE EXCEPTION TYPE cx_fatal_Exception.
  ENDTRY.
endmethod.

method RECORD.
  INCLUDE: <ICON>.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        ls_report LIKE LINE OF lt_bo_report_tab,
        lv_full_path TYPE string,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.

  ls_report-obj_name = lv_badi_impl_name.
  ls_report-method_name = lv_current_method.
  ls_report-bo_attr_name = in_bo_attr_name.
  ls_report-line_num = in_current_line.
  ls_report-line_text = ls_item-line_text.

  CASE in_name_type.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_ROOT.
      ls_report-bo_attr_type = 'ROOT NAME'. "#EC NOTEXT
      ls_report-icon = '@3M@'.
      interface2constant( EXPORTING in_interface = in_bo_attr_name IMPORTING out_constant = ls_report-bo_attr_name ).
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_NODE.
      ls_report-bo_attr_type = 'NODE NAME'. "#EC NOTEXT
      ls_report-icon = '@3Y@'.
      " meet with  Abraham
      CALL METHOD populate_whole_path
        EXPORTING
          in_current_line = in_current_line
          in_bo_attr_name = in_bo_attr_name
        IMPORTING
          out_whole_path = lv_full_path.
    IF lv_full_path IS NOT INITIAL.
      ls_report-bo_attr_name = lv_full_path.
    ENDIF.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_ASS.
      ls_report-bo_attr_type = 'ASSOCIATION NAME'. "#EC NOTEXT
      ls_report-icon = '@40@'.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_ACTION_NAME.
      ls_report-bo_attr_type = 'ACTION NAME'. "#EC NOTEXT
      ls_report-icon = '@0T@'.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_FIELD.
      ls_report-bo_attr_type = 'BO FIELD NAME'. "#EC NOTEXT
      ls_report-icon = '@4M@'.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_QUERY_NODE.
      ls_report-bo_attr_type = 'BO QUERY NODE NAME'. "#EC NOTEXT
      ls_report-icon = '@4S@'.
    WHEN /SF0A0001/SCAN_CONSTANT=>C_BO_QUERY_NAME.
      ls_report-bo_attr_type = 'BO QUERY NAME'. "#EC NOTEXT
      ls_report-icon = '@5G@'.
    WHEN OTHERS.
      ASSERT 1 = 0.
  ENDCASE.
  IF lv_work_mode = /SF0A0001/SCAN_CONSTANT=>C_MASS OR
     lv_work_mode = /SF0A0001/SCAN_CONSTANT=>C_EXPORT.
     APPEND ls_report TO lt_bo_report_tab.
     record_excel( EXPORTING in_line = ls_report in_type = in_name_type ).
     RETURN.
  ENDIF.
  IF lv_first_meet = 0.
     lv_first_meet = 1.
  ELSE.
     CLEAR: ls_report-obj_name.
  ENDIF.
  APPEND ls_report TO lt_bo_report_tab.

endmethod.

method ALPHA_CONVERSION.
  DATA: lv_string TYPE string,
        lv_count TYPE i,
        lv_len TYPE i,
        lv_second TYPE string,
        lt_string TYPE string_table.

  lv_string = in_name.

  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_COMMENT1 INTO TABLE lt_string.
     IF lines( lt_string ) > 1.
       READ TABLE lt_string INTO lv_string INDEX 1.
     ENDIF.
  ENDIF.
  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_LEFT.
     REPLACE ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_LEFT IN lv_string WITH SPACE.
  ENDIF.

  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_COMMA.
     REPLACE ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_COMMA IN lv_string WITH SPACE.
  ENDIF.

  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_RIGHT.
     REPLACE ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_RIGHT IN lv_string WITH SPACE.
  ENDIF.

  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_QUOTA.
     REPLACE ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_QUOTA IN lv_string WITH SPACE.
  ENDIF.

  FIND ALL OCCURRENCES OF /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN lv_string MATCH COUNT lv_count.
  IF lv_count = 2.
    REPLACE FIRST OCCURRENCE OF /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN lv_string WITH SPACE.
  ELSE.
     FIND /SF0A0001/SCAN_CONSTANT=>C_REFER IN lv_string.
     IF sy-subrc <> 0.
       REPLACE FIRST OCCURRENCE OF /SF0A0001/SCAN_CONSTANT=>C_EQUAL IN lv_string WITH SPACE.
     ENDIF.
  ENDIF.

  IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_END.
     CLEAR lt_string.
     SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_END INTO TABLE lt_string.
     IF lines( lt_string ) = 1.
       READ TABLE lt_string INTO lv_string INDEX 1.
     ELSE.
        READ TABLE lt_string INTO lv_second INDEX 2.
        ASSERT sy-subrc = 0.
        CONDENSE lv_second.
        lv_len = strlen( lv_second ).
        IF lv_len <= 1.
           READ TABLE lt_string INTO lv_string INDEX 1.
        ENDIF.
     ENDIF.
  ENDIF.

  condense_string( EXPORTING in_string = lv_string IMPORTING out_string = lv_string ).
  out_name = lv_string.
endmethod.

method CONDENSE_STRING.
  DATA: lt_temp TYPE string_table,
        ls_result TYPE string,
        ls_temp TYPE string.

  SPLIT in_string AT SPACE INTO TABLE lt_temp.
  LOOP AT lt_temp INTO ls_temp.
     ls_result = ls_result && ls_temp.
  ENDLOOP.

  out_string = ls_result.
endmethod.

method HANDLE_GET_OUT_DATA_NAME.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_result TYPE string,
        lv_total TYPE string,
        lv_current TYPE i,
        ls_variable TYPE ty_variable_line,
        lv_string TYPE string.

  lv_total = lines( lt_working_pool ).
  lv_current = in_current_line + 1.
  WHILE lv_current < lv_total.
     READ TABLE lt_working_pool INTO ls_item INDEX lv_current.
     FIND /SF0A0001/SCAN_CONSTANT=>C_OUT_LINK IN ls_item-line_text.
     IF sy-subrc = 0.
       RETURN.
     ENDIF.
     " potential risk here: what if a variable also named with OUT_DATA?
     FIND /SF0A0001/SCAN_CONSTANT=>C_OUT_DATA IN ls_item-line_text.
     IF sy-subrc <> 0.
        lv_current = lv_current + 1.
        CONTINUE.
     ENDIF.
     SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
     IF lines( lt_string ) <> 2.
        RETURN.
     ENDIF.

     READ TABLE lt_string INTO lv_result INDEX 2.

     CALL METHOD ALPHA_CONVERSION
        EXPORTING
           in_name = lv_result
        IMPORTING
           out_name = lv_result.

     ls_variable-variable_name = lv_result.
     APPEND ls_variable TO lt_outdata_tab.
     RETURN.
  ENDWHILE.
endmethod.

method SCAN_BO.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        lv_tab_variable_define_line TYPE i,
        lv_result TYPE i,
        line_length TYPE i.

  CLEAR: lt_outdata_tab,LT_STRUCT_TAB,lt_lcp_map,LT_LCP_TABLE.

  FILL_LCP_TABLE( ).

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/SCAN_CONSTANT=>C_COMMENT1.
     IF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_GET_LCP.
        handle_get_lcp( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_BO_NODE_NAME.
        FIND /SF0A0001/SCAN_CONSTANT=>C_END IN ls_line_pool-line_text.
        CHECK sy-subrc <> 0.
        handle_get_bo_node_name( EXPORTING in_current_line = ls_line_pool-line_num ).
        " add on 2009-04-29 after meeting with Simon,Adrian,
        " enhance it with retrieving used attribute name
        handle_get_out_data_name( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_ASS_NAME.
        handle_get_ass_name( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_IMPORTING.
        handle_get_import_data( EXPORTING in_current_line = ls_line_pool-line_num ).
     " enhance on 2009-11-03 4:06PM : add support to query
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_QUERY.
        handle_get_query_data( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_CALL_METHOD.
     " enhance on 2010-3-3 11:42AM : enhance post exit embedded call
        handle_embedded_call_method( EXPORTING in_current_line = ls_line_pool-line_num ).
     " enhance on 2010-3-3 1:54PM: enhance node name in execute action
        IF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_EXECUTE_ACTION.
           HANDLE_execute_action( EXPORTING in_current_line = ls_line_pool-line_num ).
        ENDIF.
        IF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_MOVE.
           handle_move_corresponding( EXPORTING in_current_line = ls_line_pool-line_num ).
        ENDIF.
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_EQUAL.
     " enhance on 2010-3-3 4:33PM: enhance ls-XXX = lt-XXX scenario
        handle_variable_equal_name( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSEIF ls_line_pool-line_text CS /SF0A0001/SCAN_CONSTANT=>C_MOVE.
        handle_move_corresponding( EXPORTING in_current_line = ls_line_pool-line_num ).
     ENDIF.
  ENDLOOP.

  retrieve_bo_attr_from_tab( ).

endmethod.

method GET_BADI_INFO.
  lv_badi_impl_name = im_badi_name.
endmethod.

method FILL_SOURCE_TABLE.
  DATA: ls_source LIKE LINE OF lt_working_source,
        ls_line TYPE TY_LINE.
  CLEAR: lt_working_pool.
  LOOP AT lt_working_source INTO ls_source.
    ls_line-line_num = sy-tabix.
    ls_line-line_text = ls_source.
    TRANSLATE ls_line-line_text TO UPPER CASE.
    APPEND ls_line TO lt_working_pool.
    CLEAR: ls_line.
  ENDLOOP.

endmethod.

method GET_INTERFACE_SOURCE.

 DATA: lv_class TYPE SEOCLSKEY,
       lt_section_source TYPE SEO_SECTION_SOURCE,
       lv_incname TYPE PROGRAM,
       lt_SEOR_IMPLEMENTINGS_R TYPE SEOR_IMPLEMENTINGS_R,
       lt_SEO_REDEFINITIONS TYPE SEO_REDEFINITIONS,
       method_key type SEOCPDKEY.


 lv_class-CLSNAME = lv_badi_impl_name.

 CALL FUNCTION 'SEO_IMPLEMENTG_READ_ALL'
    EXPORTING
       CLSKEY = lv_class
    IMPORTING
       IMPLEMENTINGS = lt_SEOR_IMPLEMENTINGS_R
       IMPL_DETAILS = lt_SEO_REDEFINITIONS.

 IF lt_SEOR_IMPLEMENTINGS_R IS INITIAL.
    ASSERT 1 = 0.
 ENDIF.

 method_key-CLSNAME = lv_badi_impl_name.
 method_key-CPDNAME = 'IF_SPAF_ENHANCE_ASSEMBLE_MSG~ENHANCE_ASSEMBLE_MSG'.
 lv_current_method = 'ENHANCE_ASSEMBLE_MSG'.
 CLEAR lt_working_source.
 CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
    EXPORTING
      MTDKEY = method_key
    IMPORTING
      SOURCE_expanded = lt_working_source.

endmethod.

method HANDLE_GET_LCP.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_LCP_FACADE IN ls_item-line_text.
  CHECK sy-subrc <> 0.
  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_LEFT INTO TABLE lt_string.
  IF lines( lt_string ) >= 2.
    READ TABLE lt_string INTO lv_string INDEX 2.
    ASSERT sy-subrc = 0.
    IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_BO_NAME.
       CLEAR: lt_string.
       SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_BO_NAME INTO TABLE lt_string.
       READ TABLE lt_string INTO lv_string INDEX 2.
       ASSERT sy-subrc = 0.
    ENDIF.

    CALL METHOD ALPHA_CONVERSION
       EXPORTING
         in_name = lv_string
       IMPORTING
         out_name = lv_string.
    try_find_lcp_variable( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string ).
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ROOT ).
    "WRITE:/ 'LCP: ' ,lv_string, 'line:' , in_current_line.
  ELSE.
    handle_get_lcp_next_line( EXPORTING in_current_line = in_current_line + 1 ).
  ENDIF.

endmethod.

method HANDLE_GET_LCP.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  FIND /SF0A0001/SCAN_CONSTANT=>C_LCP_FACADE IN ls_item-line_text.
  CHECK sy-subrc <> 0.
  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_LEFT INTO TABLE lt_string.
  IF lines( lt_string ) >= 2.
    READ TABLE lt_string INTO lv_string INDEX 2.
    ASSERT sy-subrc = 0.
    IF lv_string CS /SF0A0001/SCAN_CONSTANT=>C_BO_NAME.
       CLEAR: lt_string.
       SPLIT lv_string AT /SF0A0001/SCAN_CONSTANT=>C_BO_NAME INTO TABLE lt_string.
       READ TABLE lt_string INTO lv_string INDEX 2.
       ASSERT sy-subrc = 0.
    ENDIF.

    CALL METHOD ALPHA_CONVERSION
       EXPORTING
         in_name = lv_string
       IMPORTING
         out_name = lv_string.
    try_find_lcp_variable( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string ).
    record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_string in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ROOT ).
    "WRITE:/ 'LCP: ' ,lv_string, 'line:' , in_current_line.
  ELSE.
    handle_get_lcp_next_line( EXPORTING in_current_line = in_current_line + 1 ).
  ENDIF.

endmethod.
method HANDLE_GET_BO_NODE_NAME.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_result TYPE string,
        lv_total TYPE string,
        lv_current TYPE i VALUE 2,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  lv_total = lines( lt_string ).
  ASSERT lv_total > 0.

  WHILE lv_current <= lv_total.
    READ TABLE lt_string INTO lv_string INDEX lv_current.
    ASSERT sy-subrc = 0.
    lv_current = lv_current + 1.
    IF lv_result IS INITIAL.
       lv_result = lv_string.
    ELSE.
       lv_result = lv_result && /SF0A0001/SCAN_CONSTANT=>C_EQUAL && lv_string.
    ENDIF.
  ENDWHILE.

  " TO DO : beautify needed!
  CALL METHOD ALPHA_CONVERSION
     EXPORTING
        in_name = lv_result
     IMPORTING
        out_name = lv_result.

  " WRITE:/ 'BO Node Name:' ,lv_result, 'line: ' , in_current_line.
  record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_result in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_NODE ).
endmethod.

method HANDLE_GET_ASS_NAME.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_result TYPE string,
        lv_total TYPE string,
        lv_current TYPE i VALUE 2,
        lv_string TYPE string.

  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  ASSERT sy-subrc = 0.
  SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
  lv_total = lines( lt_string ).
  ASSERT lv_total > 0.

  WHILE lv_current <= lv_total.
    READ TABLE lt_string INTO lv_string INDEX lv_current.
    ASSERT sy-subrc = 0.
    lv_current = lv_current + 1.
    IF lv_result IS INITIAL.
       lv_result = lv_string.
    ELSE.
       lv_result = lv_result && /SF0A0001/SCAN_CONSTANT=>C_EQUAL && lv_string.
    ENDIF.
  ENDWHILE.

  " TO DO : beautify needed!
  CALL METHOD ALPHA_CONVERSION
    EXPORTING
      in_name = lv_result
    IMPORTING
      out_name = lv_result.
  record( EXPORTING in_current_line = in_current_line in_bo_attr_name = lv_result in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ASS ).
  "WRITE:/ 'ASS Name:' ,lv_result, 'line: ' , in_current_line.
endmethod.

method HANDLE_GET_LCP_NEXT_LINE.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lt_string TYPE string_table,
        lv_index TYPE i,
        lv_max_line TYPE i,
        lv_total TYPE i,
        lv_result TYPE string,
        lv_current TYPE i VALUE 2,
        lv_string TYPE string.

  lv_max_line = lines( lt_working_pool ).
  lv_index = in_current_line.
  WHILE lv_index < lv_max_line.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    IF ls_item-line_text CS /SF0A0001/SCAN_CONSTANT=>C_END.
       RETURN.
    ENDIF.
    IF ls_item-line_text CS /SF0A0001/SCAN_CONSTANT=>C_BO_NAME.
       SPLIT ls_item-line_text AT /SF0A0001/SCAN_CONSTANT=>C_EQUAL INTO TABLE lt_string.
       lv_total = lines( lt_string ).
       ASSERT lv_total > 0.
       WHILE lv_current <= lv_total.
         READ TABLE lt_string INTO lv_string INDEX lv_current.
         ASSERT sy-subrc = 0.
         lv_current = lv_current + 1.
         IF lv_result IS INITIAL.
           lv_result = lv_string.
         ELSE.
           lv_result = lv_result && /SF0A0001/SCAN_CONSTANT=>C_EQUAL && lv_string.
         ENDIF.
       ENDWHILE.
       CALL METHOD ALPHA_CONVERSION
         EXPORTING
           in_name = lv_result
         IMPORTING
           out_name = lv_result.
       record( EXPORTING in_current_line = lv_index in_bo_attr_name = lv_result in_name_type = /SF0A0001/SCAN_CONSTANT=>C_BO_ROOT ).
       "WRITE:/ 'Bo Name: ' , lv_result, 'line:' , ls_item-line_num.
       FILL_LCP_MAP_NEXT_LINE( EXPORTING in_current_line = lv_index in_bo_attr_name = lv_result ).
       RETURN.
    ENDIF.
    lv_index = lv_index + 1.
  ENDWHILE.

  ASSERT 1 = 0.

endmethod.

10. /SF0A0001/BADI_CODE_INSPECTOR
class /SF0A0001/BADI_CODE_INSPECTOR definition
  public
  final
  create public .

public section.
*"* public components of class /SF0A0001/BADI_CODE_INSPECTOR
*"* do not include other source files here!!!

  types:
    BEGIN OF ty_error_log,
          class_name TYPE string,
          method_name TYPE string,
          author TYPE string,
          error_type TYPE string,
          error_line TYPE string,
          error_text TYPE string,
          description TYPE string,
    END OF ty_error_log .
  types:
    tt_error_log TYPE STANDARD TABLE OF ty_error_log .

  class-data LV_REMOTE type STRING value 'MAIL.DOC'. "#EC NOTEXT .
  class-data LV_BADI_DOC_LOCAL type STRING value 'C:and Settings.doc'. "#EC NOTEXT .
  class-data LV_LOCAL_FILE_NAME type STRING value 'badi.doc'. "#EC NOTEXT .

  class-methods ADJUST_TASK
    importing
      !IN_INDEX type STRING
      !IN_CHECK type STRING .
  class-methods VALIDATE_FOR_UI
    exporting
      value(OUT_ERROR) type C .
  class-methods SET_WORK_MODE
    importing
      !IN_WORK_MODE type I .
  class-methods SET_SYSTEM
    importing
      !IN_SYSTEM_NAME type STRING .
  class-methods RUN_FOR_UI
    importing
      !IN_IMPL_CLASS_NAME type STRING
    exporting
      !OUT_ERRORS type TT_ERROR_LOG .
  class-methods GET_BADI_IMPLEMENT_CLASS
    importing
      !IN_ENH_NAME type STRING
    exporting
      !OUT_IMPL_CLASS_NAME type STRING .
  class-methods OPEN_HELP_DOC .
  class-methods CLEAR .
  class-methods F4_HELP_FOR_BADI
    importing
      !IV_DYNPROFLD type HELP_INFO-DYNPROFLD .
  class-methods F4_HELP_FOR_EXIT
    importing
      !IV_DYNPROFLD type HELP_INFO-DYNPROFLD .
  class-methods FILL_TASK
    importing
      !IN_OUTPUT_REQUEST type C
      !IN_FS_CHECK type C
      !IN_REF_CHECK type C
      !IN_READ_CHECK type C
      !IN_CLEAR_CHECK type C .
  class-methods DISPLAY .
  class-methods RUN
    importing
      !IN_BADI_IMPL_NAME type ENHNAME .
private section.
*"* private components of class /SF0A0001/BADI_CODE_INSPECTOR
*"* do not include other source files here!!!

  types SEOR_IMPLEMENTING_R type VSEOIMPLEM .
  types SEOP_SOURCE_STRING type RSWSOURCET .
  types:
    SEOR_IMPLEMENTINGS_R TYPE STANDARD TABLE OF SEOR_IMPLEMENTING_R
    WITH KEY CLSNAME REFCLSNAME VERSION .
  types:
    BEGIN OF ty_line,
           line_num TYPE i,
           line_text TYPE string,
         END OF ty_line .
  types:
    tt_line TYPE STANDARD TABLE OF ty_line WITH KEY line_num .
  types:
    BEGIN OF ty_rfc_line,
           CLSNAME TYPE char30,
           CMPNAME TYPE char30,
         END OF ty_rfc_line .
  types:
    tt_rfc_method TYPE TABLE OF ty_rfc_line .

  class-data LT_ERROR_LOG type TT_ERROR_LOG .
  class-data LV_DESTINATION type STRING .
  class-data LV_WORK_MODE type I value 0. "#EC NOTEXT .
  class-data LV_SYSTEM type STRING .
  class-data LV_RFC_MODE type I value 0. "#EC NOTEXT .
  class-data LV_EMAIL_ADDRESS type STRING .
  class-data LV_PDF type XSTRING .
  class-data LT_IMPORT_TAB type STRING_TABLE .
  class-data LV_IN_METHOD type I .
  class-data LV_FS_CHECK type C .
  class-data LV_OR_CHECK type C .
  class-data LV_CLEAR_CHECK type C .
  class-data LV_READ_CHECK type C .
  class-data LV_REFER_CHECK type C .
  class-data LV_FIRST_ERROR type I .
  class-data LT_REFERENCE_TAB type STRING_TABLE .
  class-data LT_FIELD_SYMBOL_TAB type STRING_TABLE .
  class-data LV_CURRENT_METHOD type STRING .
  class-data LV_AUTHOR type STRING .
  class-data LV_ERROR_FLAG type I .
  class-data LV_CURRENT_VARIABLE type STRING .
  class-data LT_WORKING_POOL type TT_LINE .
  type-pools SEOP .
  class-data LT_WORKING_SOURCE type SEOP_SOURCE_STRING .
  class-data LV_BADI_IMPL_NAME type STRING .

  class-methods _FIND_ASSIGNED_IN_TABLE_READ
    importing
      !IN_CURRENT_LINE type I .
  class-methods RUN_WITH_EXIT
    importing
      !IN_POST_EXIT_NAME type ENHNAME .
  class-methods INIT_POST_EXIT
    importing
      !IN_POST_EXIT_NAME type ENHNAME .
  class-methods FILL_POST_EXIT_WORKING_POOL .
  type-pools SEOO .
  class-methods GET_METHOD_RFC
    importing
      !IN_CLASS_NAME type SEOCLSNAME
    exporting
      !OUT_METHOD_TAB type SEOO_METHODS_R .
  class-methods CHECK_POST_LOOP_CLEAR
    importing
      !IN_CURRENT_LINE type I
      !IN_BOTTOM_RANGE type I
    exporting
      !OUT_RESULT type I .
  class-methods FILL_EMAIL_ADDRESS .
  class-methods GET_INUMBER
    exporting
      !OUT_INUMBER type STRING .
  class-methods GET_SOURCE_CODE_RFC
    importing
      !IN_CLASS_NAME type SEOCLSNAME
      !IN_METHOD_NAME type SEOCPDNAME .
  class-methods LOG_WITH_TEXT
    importing
      !IN_TEXT type STRING .
  class-methods POPULATE_FILE_PATH
    exporting
      !OUT_PATH type STRING .
  class-methods SEND_MAIL .
  class-methods GENERATE_PDF .
  class-methods PRE_HANDLE_ENTRY .
  class-methods SEARCH_IMPORT
    importing
      !IN_CURRENT_LINE type I
      !IN_DATA_DEFINE_LINE type I .
  class-methods LOG .
  class-methods _FIND_CLEAR_IMPORT_TAB
    importing
      !IN_CURRENT_LINE type I .
  class-methods HAS_LOOP
    importing
      !IN_CURRENT_LINE type I
    exporting
      !OUT_RESULT type I
      !OUT_TOP_RANGE type I
      !OUT_BOTTOM_RANGE type I .
  class-methods HAS_CLEAR_STATEMENT
    importing
      !IN_BOTTOM_RANGE type I optional
      !IN_CURRENT_LINE type I
    exporting
      !OUT_RESULT type I .
  class-methods FIND_IMPORT_TAB
    importing
      !IN_CURRENT_LINE type I .
  class-methods FILL_IMPORT_TAB
    importing
      !IN_CURRENT_LINE type I .
  class-methods CONTAINS_ONLY
    importing
      !IN_LINE_TEXT type STRING
    returning
      value(OUT_RESULT) type I .
  class-methods CHECK_TABLE_VARIABLE .
  class-methods CHECK_CLEAR_IMPORT_TAB .
  class-methods CHECK_READ_TABLE .
  class-methods _FIND_SUBRC
    importing
      !IN_CURRENT_LINE type I .
  class-methods CHECK_REFER_VARIABLE .
  class-methods FILL_REFERENCE_TAB
    importing
      !IN_CURRENT_LINE type I .
  class-methods MY_CONDENSE
    importing
      !IN_STRING type STRING
    exporting
      !OUT_STRING type STRING .
  class-methods _FIND_REF_CHECK_STATEMENT
    importing
      !IN_CURRENT_LINE type I .
  class-methods SCAN_REFER_VARIABLE .
  class-methods CHECK_FIELD_SYMBOL .
  class-methods FILL_FIELD_SYMBOL_TAB
    importing
      !IN_CURRENT_LINE type I .
  class-methods _FIND_FS_CHECK_STATEMENT
    importing
      !IN_CURRENT_LINE type I .
  class-methods SCAN_FIELD_SYMBOL .
  class-methods GET_AUTHOR .
  class-methods CHECK_OUTPUT_REQUEST .
  class-methods FETCH_VARIABLE_NAME
    importing
      !IN_STRING_TABLE type STRING_TABLE .
  class-methods _FIND_CHECK_OUTPUT_REQ
    importing
      !IN_CURRENT_LINE type I
      !IN_UPPER_RANGE type I .
  class-methods FIND_UPPER_RANGE
    importing
      !IN_CURRENT_LINE type I
    returning
      value(UPPER_LINE) type I .
  class-methods PACK_STRING_TABLE
    changing
      !C_STRING_TABLE type STRING_TABLE .
  class-methods GET_BADI_INFO
    importing
      !IM_BADI_NAME type ENHNAME .
  class-methods INIT
    importing
      !IN_BADI_IMPL_NAME type ENHNAME .
  class-methods FILL_SOURCE_TABLE .
  class-methods GET_INTERFACE_SOURCE .
method ADJUST_TASK.
  DATA: index TYPE i.

  index = in_index.
  CASE index.
    WHEN 1.
      lv_or_check = in_check.
    WHEN 2.
      lv_fs_check = in_check.
    WHEN 3.
      lv_refer_check = in_check.
    WHEN 4.
      lv_read_check = in_check.
    WHEN 5.
      lv_clear_check = in_check.
    WHEN OTHERS.
      ASSERT index > 5.
  ENDCASE.

endmethod.

method VALIDATE_FOR_UI.
  IF lv_or_check = 'X'.
    out_error = SPACE.
    RETURN.
  ENDIF.

  IF lv_fs_check = 'X'.
    out_error = SPACE.
    RETURN.
  ENDIF.

  IF lv_refer_check = 'X'.
    out_error = SPACE.
    RETURN.
  ENDIF.

  IF lv_read_check = 'X'.
    out_error = SPACE.
    RETURN.
  ENDIF.

  IF lv_clear_check = 'X'.
    out_error = SPACE.
    RETURN.
  ENDIF.
  out_error = 'X'.
endmethod.

method SET_WORK_MODE.
  lv_work_mode = in_work_mode.
endmethod.

method SET_SYSTEM.
  DATA: lt_destination TYPE TABLE OF /SF0A0001/RFC_DE,
        ls_destination TYPE /SF0A0001/RFC_DE.
  lv_system = in_system_name.

  "work around
  IF lv_system <> 'S9E' AND lv_system <> /SF0A0001/BADI_INTERFACE=>C_HOST.
    MESSAGE e021(/SF0A0001/BADI_INSPE) WITH lv_system.
  ENDIF.
  IF lv_system <> /SF0A0001/BADI_INTERFACE=>C_HOST.
     lv_rfc_mode = 1.
     SELECT * FROM /SF0A0001/RFC_DE INTO TABLE lt_destination WHERE system_name = lv_system.
     ASSERT lines( lt_destination ) = 1.
     READ TABLE lt_destination INTO ls_destination INDEX 1.
     lv_destination = ls_destination-destination.
     IF lv_destination IS INITIAL.
        MESSAGE e022(/SF0A0001/BADI_INSPE) WITH lv_system.
     ENDIF.
     ASSERT lv_destination IS NOT INITIAL.
  ENDIF.

endmethod.

method RUN_FOR_UI.
  lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_SINGLE.

  CLEAR:
     lt_working_pool,
     lt_working_source,
     lv_badi_impl_name,
     lv_current_variable,
     lv_error_flag,
     lv_current_method,
     lt_field_symbol_tab,
     lt_reference_tab,
     lt_import_tab,
     lv_author,
     lt_error_log,
     lv_in_method,
     lv_first_error.

  lv_badi_impl_name = in_impl_class_name.

  GET_INTERFACE_SOURCE( ).

  FILL_SOURCE_TABLE( ).

  CHECK lt_working_pool IS NOT INITIAL.

  IF lv_or_check = 'X'.
     CHECK_OUTPUT_REQUEST( ).
  ENDIF.

  IF lv_fs_check = 'X'.
     GET_INTERFACE_SOURCE( ).
     FILL_SOURCE_TABLE( ).
     CHECK_FIELD_SYMBOL( ).
  ENDIF.

  IF lv_refer_check = 'X'.
     GET_INTERFACE_SOURCE( ).
     FILL_SOURCE_TABLE( ).
     CHECK_REFER_VARIABLE( ).
  ENDIF.

  IF lv_read_check = 'X'.
     GET_INTERFACE_SOURCE( ).
     FILL_SOURCE_TABLE( ).
     CHECK_READ_TABLE( ).
  ENDIF.

  IF lv_clear_check = 'X'.
     GET_INTERFACE_SOURCE( ).
     FILL_SOURCE_TABLE( ).
     CHECK_CLEAR_IMPORT_TAB( ).
  ENDIF.

  out_errors = lt_error_log.

endmethod.

method GET_BADI_IMPLEMENT_CLASS.

  DATA: lo_enh_impl TYPE REF TO if_enh_tool,
        lo_badi_impl_tool TYPE REF TO cl_enh_tool_badi_impl,
        lx_badi_impl_error TYPE REF TO CX_ENH_BADI_IMPL_NOT_VALID,
        lx_io_error TYPE REF TO CX_ENH_IO_ERROR,
        lv_error TYPE string,
        lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        name TYPE ENHNAME,
        ex_badi_info TYPE ENH_BADI_IMPL_DATA.

  name = in_enh_name.
  TRY.
    lo_enh_impl = cl_enh_factory=>get_enhancement(
          enhancement_id         = name ).
    CATCH CX_ENH_IO_ERROR into lx_io_error.
       ASSERT 1 = 0.
  ENDTRY.

  lo_badi_impl_tool ?= lo_enh_impl.
  " bug reported by Yoyo on 2009/04/08: impl must be used instead of enh name
  SELECT ENHNAME ACTIVE BADI_IMPL FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME = name.
  ASSERT lines( lt_badi_table ) = 1.
  READ TABLE lt_badi_table INTO ls_badi INDEX 1.
  ASSERT sy-subrc = 0.

  TRY.
     CALL METHOD lo_badi_impl_tool->GET_IMPLEMENTATION
       EXPORTING
          IMPL_NAME         = ls_badi-BADI_IMPL
       RECEIVING
          RE_IMPLEMENTATION = ex_badi_info.

  CATCH CX_ENH_BADI_IMPL_NOT_VALID into lx_badi_impl_error.
     ASSERT 1 = 0.
  ENDTRY.

  ASSERT ex_badi_info IS NOT INITIAL.

  out_impl_class_name = ex_badi_info-IMPL_CLASS.

endmethod.

method OPEN_HELP_DOC.
  TYPES: t_raw(1024) TYPE x.
  DATA: lv_xstring TYPE xstring,
        lv_xlength TYPE i,
        lv_exist TYPE c,
        lv_text TYPE string,
        lv_file_name TYPE string,
        l_binary_table   TYPE TABLE OF t_raw.

  OPEN DATASET /SF0A0001/BADI_CODE_INSPECTOR=>LV_REMOTE FOR INPUT IN BINARY MODE.
  lv_text = 'Opening File in ' && sy-host. "#EC NOTEXT
  log_with_text( EXPORTING in_text = lv_text ).
  IF sy-subrc <> 0.
     MESSAGE e017(/SF0A0001/BADI_INSPE) WITH sy-host.
  ENDIF.
  lv_text = 'Reading File in ' && sy-host. "#EC NOTEXT
  log_with_text( EXPORTING in_text = lv_text ).
  READ DATASET /SF0A0001/BADI_CODE_INSPECTOR=>LV_REMOTE INTO lv_xstring.
  IF sy-subrc <> 0.
     MESSAGE e018(/SF0A0001/BADI_INSPE) WITH sy-subrc.
  ENDIF.
  lv_xlength = xstrlen( lv_xstring ).
  IF lv_xlength <= 0.
     MESSAGE e019(/SF0A0001/BADI_INSPE) WITH lv_xlength.
  ENDIF.

  CLOSE DATASET /SF0A0001/BADI_CODE_INSPECTOR=>LV_REMOTE.

  CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
    EXPORTING
      buffer        = lv_xstring
    IMPORTING
      output_length = lv_xlength
    TABLES
      binary_tab    = l_binary_table.

  populate_file_path( IMPORTING out_path = lv_file_name ).

  CALL METHOD cl_gui_frontend_services=>FILE_EXIST
     EXPORTING
       file = lv_file_name
     RECEIVING
       RESULT = lv_exist.
  IF lv_exist <> 'X'.
   CALL FUNCTION 'GUI_DOWNLOAD'
     EXPORTING
        FILENAME = lv_file_name
        FILETYPE = 'BIN'
     IMPORTING
        FILELENGTH = lv_xlength
     TABLES
        DATA_TAB = l_binary_table.
  ENDIF.
  lv_text = 'Opening File... '. "#EC NOTEXT
  log_with_text( EXPORTING in_text = lv_text ).
  CALL METHOD cl_gui_frontend_services=>execute
    EXPORTING
      DOCUMENT = lv_file_name
      OPERATION = 'OPEN'
    EXCEPTIONS
      CNTL_ERROR = 1
      ERROR_NO_GUI = 2
      BAD_PARAMETER = 3
      FILE_NOT_FOUND = 4
      PATH_NOT_FOUND = 5
      FILE_EXTENSION_UNKNOWN = 6
      ERROR_EXECUTE_FAILED = 7
      SYNCHRONOUS_FAILED = 8
      NOT_SUPPORTED_BY_GUI = 9
    OTHERS = 10.
  IF sy-subrc <> 0.

  ENDIF.

endmethod.

method CLEAR.
  DELETE FROM /SF0A0001/PICLOG WHERE USERNAME = sy-uname.
  COMMIT WORK AND WAIT.
endmethod.

method F4_HELP_FOR_BADI.
  TYPES:
        BEGIN OF f4list_s,
           badi   TYPE ENHNAME,
        END OF f4list_s.

  DATA: lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        ls_f4 TYPE f4list_s,
        lt_f4 TYPE TABLE OF f4list_s.

  SELECT ENHNAME ACTIVE FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME LIKE '/SFA%'.

  LOOP AT lt_badi_table INTO ls_badi.
     CLEAR ls_f4.
     ls_f4-badi = ls_badi-enhname.
     APPEND ls_f4 TO lt_f4.
  ENDLOOP.

  IF lt_f4 IS INITIAL.
     RETURN.
  ENDIF.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'BADIIMPL_ENH'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = iv_dynprofld
      value_org       = 'S'
    TABLES
      value_tab       = lt_f4
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
endmethod.

method F4_HELP_FOR_BADI.
  TYPES:
        BEGIN OF f4list_s,
           badi   TYPE ENHNAME,
        END OF f4list_s.

  DATA: lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        ls_f4 TYPE f4list_s,
        lt_f4 TYPE TABLE OF f4list_s.

  SELECT ENHNAME ACTIVE FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME LIKE '/SFA%'.

  LOOP AT lt_badi_table INTO ls_badi.
     CLEAR ls_f4.
     ls_f4-badi = ls_badi-enhname.
     APPEND ls_f4 TO lt_f4.
  ENDLOOP.

  IF lt_f4 IS INITIAL.
     RETURN.
  ENDIF.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'BADIIMPL_ENH'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = iv_dynprofld
      value_org       = 'S'
    TABLES
      value_tab       = lt_f4
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
endmethod.

method F4_HELP_FOR_EXIT.
  TYPES:
        BEGIN OF f4list_s,
           badi   TYPE ENHNAME,
        END OF f4list_s.

  DATA: lt_badi_table TYPE TABLE OF enhsort,
        ls_badi TYPE enhsort,
        ls_f4 TYPE f4list_s,
        lv_name TYPE string,
        lt_f4 TYPE TABLE OF f4list_s.

  SELECT enhname FROM enhsort INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE version = 'A' AND ENHNAME LIKE '/SFA%'.

  LOOP AT lt_badi_table INTO ls_badi.
     CLEAR ls_f4.
     ls_f4-badi = ls_badi-enhname.
     APPEND ls_f4 TO lt_f4.
  ENDLOOP.

  IF lt_f4 IS INITIAL.
     RETURN.
  ENDIF.

  CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
    EXPORTING
      retfield        = 'ENHSORT'
      dynpprog        = sy-repid
      dynpnr          = sy-dynnr
      dynprofield     = iv_dynprofld
      value_org       = 'S'
    TABLES
      value_tab       = lt_f4
    EXCEPTIONS
      parameter_error = 1
      no_values_found = 2
      OTHERS          = 3.
endmethod.

method FILL_TASK.

  IF in_output_request IS INITIAL AND in_fs_check IS INITIAL
     AND in_ref_check IS INITIAL AND in_read_check IS INITIAL AND in_clear_check IS INITIAL.
     MESSAGE e011(/SF0A0001/BADI_INSPE).
  ENDIF.
  lv_OR_CHECK = in_output_request.
  lv_fs_check = in_fs_check.
  lv_refer_check = in_ref_check.
  lv_read_check = in_read_check.
  lv_clear_check = in_clear_check.

endmethod.

method DISPLAY.
  DATA: gr_alv TYPE REF TO cl_salv_table,
        column_table TYPE REF TO CL_SALV_COLUMNS_TABLE,
        column TYPE REF TO CL_SALV_COLUMN,
        gr_selections TYPE REF TO cl_salv_selections,
        gr_events TYPE REF TO cl_salv_events_table,
        lx_alv_ex TYPE REF TO CX_SALV_MSG,
        lv_mesg TYPE string,
        lo_event_handler TYPE REF TO /SF0A0001/CI_EVENT_HANDLER.

  FILL_EMAIL_ADDRESS( ).
  GENERATE_PDF( ).
  SEND_MAIL( ).
  IF lt_error_log IS INITIAL.
     MESSAGE I012(/SF0A0001/BADI_INSPE).
     RETURN.
  ENDIF.

  SORT lt_error_log BY AUTHOR.

  TRY.
    CALL METHOD cl_salv_table=>factory
      IMPORTING
        r_salv_table   = gr_alv
      CHANGING
        t_table        = lt_error_log.
    CATCH CX_SALV_MSG INTO lx_alv_ex.
       lv_mesg = lx_alv_ex->get_text( ).
       MESSAGE E015(/SF0A0001/BADI_INSPE) WITH lv_mesg.
  ENDTRY.

  " Set up selections.
  gr_selections = gr_alv->get_selections( ).
  gr_selections->set_selection_mode( 1 ). "Single

  gr_events = gr_alv->get_event( ).
  CREATE OBJECT lo_event_handler.
  lo_event_handler->init( EXPORTING in_error_table = lt_error_log in_code_inspe_mode = lv_work_mode ).
  IF lv_rfc_mode = 0.
     SET HANDLER lo_event_handler->on_double_click FOR gr_events.
  ENDIF.
  " Display
  column_table = gr_alv->GET_COLUMNS( ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'CLASS_NAME' ).
  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_SINGLE OR
     lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_MASS.
     column->SET_MEDIUM_TEXT( 'Badi Class' ). "#EC NOTEXT
  ELSE.
      column->SET_MEDIUM_TEXT( 'Post Exit' ). "#EC NOTEXT
  ENDIF.
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'METHOD_NAME' ).
  column->SET_MEDIUM_TEXT( 'Method Name' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'AUTHOR' ).
  column->SET_MEDIUM_TEXT( 'Author' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 10 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'ERROR_TYPE' ).
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 4 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'ERROR_LINE' ).
  column->SET_MEDIUM_TEXT( 'Line' ). "#EC NOTEXT
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 4 ).

  column = column_table->GET_COLUMN( COLUMNNAME = 'ERROR_TEXT' ).
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 70 ).
  column->SET_MEDIUM_TEXT( 'Error Source Code' ). "#EC NOTEXT

  column = column_table->GET_COLUMN( COLUMNNAME = 'DESCRIPTION' ).
  column->SET_OPTIMIZED( exporting value = 'X' ).
  column->SET_OUTPUT_LENGTH( exporting value = 30 ).
  column->SET_MEDIUM_TEXT( 'Error Description' ). "#EC NOTEXT

  CALL METHOD gr_alv->display.
endmethod.

method RUN.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.

     CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>RUN_WITH_EXIT
        EXPORTING
          in_post_exit_name = in_badi_impl_name.
     RETURN.
  ENDIF.
  CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>INIT
     EXPORTING
       in_badi_impl_name = in_badi_impl_name.

  CHECK lv_error_flag = 0.

  GET_INTERFACE_SOURCE( ).

  FILL_SOURCE_TABLE( ).

  IF lt_working_pool IS INITIAL.
    IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_SINGLE."lv_mass_mode <> 'X'.
       MESSAGE e020(/SF0A0001/BADI_INSPE) with LV_BADI_IMPL_NAME lv_system.
    ENDIF.
    RETURN.
  ENDIF.
  " main method source is loaded here has SPACE to improve
  " currently the source code is loaded multiple times, low performance
  " but reduce progeamming complexity
  IF lv_or_check = 'X'.
    CHECK_OUTPUT_REQUEST( ).
  ENDIF.

  IF lv_fs_check = 'X'.
    GET_INTERFACE_SOURCE( ).
    FILL_SOURCE_TABLE( ).
    CHECK_FIELD_SYMBOL( ).
  ENDIF.

  IF lv_refer_check = 'X'.
    GET_INTERFACE_SOURCE( ).
    FILL_SOURCE_TABLE( ).
    CHECK_REFER_VARIABLE( ).
  ENDIF.

  IF lv_read_check = 'X'.
    GET_INTERFACE_SOURCE( ).
    FILL_SOURCE_TABLE( ).
    CHECK_READ_TABLE( ).
  ENDIF.

  IF lv_clear_check = 'X'.
    GET_INTERFACE_SOURCE( ).
    FILL_SOURCE_TABLE( ).
    CHECK_CLEAR_IMPORT_TAB( ).
  ENDIF.

endmethod.

method _FIND_ASSIGNED_IN_TABLE_READ.
  DATA: lv_current_index TYPE i,
        lv_max_level TYPE i VALUE 5,
        ls_line_pool LIKE LINE OF lt_working_pool,
        lt_string_table TYPE string_table,
        ls_error_log TYPE ty_error_log,
        line_length TYPE i,
        lv_max_line TYPE i.

  lv_max_line = in_current_line + lv_max_level.
  lv_current_index = in_current_line.
  WHILE lv_current_index < lv_max_line.
     READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_current_index.
     line_length = strlen( ls_line_pool-line_text ).
     IF line_length = 0 OR ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT
        OR ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
        lv_current_index = lv_current_index + 1.
        CONTINUE.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_FS_CHECK IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_SYSTEM_RETURN IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     lv_current_index = lv_current_index + 1.
  ENDWHILE.

  CLEAR ls_line_pool.
  READ TABLE lt_working_pool INTO ls_line_pool INDEX in_current_line.
  IF lv_first_error = 0.
     lv_first_error = 1.
     CLEAR ls_error_log.
     ls_error_log-class_name = lv_badi_impl_name.
  ENDIF.
  ls_error_log-error_type = '@09@'.
  ls_error_log-error_line = ls_line_pool-line_num.
  ls_error_log-error_text = ls_line_pool-line_text.
  "ls_error_log-class_name = lv_badi_impl_name.
  ls_error_log-method_name = lv_current_method.
  ls_error_log-author = lv_author.
  ls_error_log-description = 'Field Symbol must be Checked Before Used!'. "#EC NOTEXT
  APPEND ls_error_log TO lt_error_log.

endmethod.

method RUN_WITH_EXIT.
  CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>INIT_POST_EXIT
     EXPORTING
       in_post_exit_name = in_post_exit_name.

  " execution here is the assumption that working_pool has already been filled!

  IF lv_fs_check = 'X'.
    CHECK_FIELD_SYMBOL( ).
  ENDIF.

  IF lv_refer_check = 'X'.
    CHECK_REFER_VARIABLE( ).
  ENDIF.

  IF lv_read_check = 'X'.
    CHECK_READ_TABLE( ).
  ENDIF.

  IF lv_clear_check = 'X'.
    CHECK_CLEAR_IMPORT_TAB( ).
  ENDIF.
endmethod.

method INIT_POST_EXIT.
   CLEAR:
     lt_working_pool,
     lt_working_source,
     lv_badi_impl_name,
     lv_current_variable,
     lv_error_flag,
     lv_current_method,
     lt_field_symbol_tab,
     lt_reference_tab,
     lt_import_tab,
     lv_author,
     lv_in_method,
     lv_first_error.

   lv_badi_impl_name = in_post_exit_name.

   FILL_POST_EXIT_WORKING_POOL( ).

   GET_AUTHOR( ).
endmethod.

method FILL_POST_EXIT_WORKING_POOL.
  DATA: lv_enh_name2 TYPE char256,
        lv_enh_name TYPE ENHNAME,
        itab TYPE string_table,
        ls_source TYPE string,
        ls_line LIKE LINE OF lt_working_pool.

  SELECT enhname FROM enhsort INTO lv_enh_name2 WHERE version = 'A' AND ENHNAME = lv_badi_impl_name.
  ASSERT sy-subrc = 0.
  ENDSELECT.

  lv_enh_name = lv_badi_impl_name.
  TRANSLATE lv_enh_name USING ' ='.
  CONCATENATE lv_enh_name 'EIMP' INTO lv_enh_name2.
  READ REPORT lv_enh_name2 INTO itab.

  LOOP AT itab INTO ls_source.
     ls_line-line_num = sy-tabix.
     ls_line-line_text = ls_source.
     TRANSLATE ls_line-line_text TO UPPER CASE.
     APPEND ls_line TO lt_working_pool.
     CLEAR: ls_line.
  ENDLOOP.

endmethod.

method GET_METHOD_RFC.

  DATA: ls_rfc_method TYPE char30,
        lt_rfc_method LIKE TABLE OF ls_rfc_method,
        ls_out_method LIKE LINE OF out_method_tab.
  CALL FUNCTION '/SF0A0006/GET_METHOD_TAB' DESTINATION lv_destination
    EXPORTING
      IN_CLASS_NAME = in_class_name
    IMPORTING
      out_tab = lt_rfc_method.

  LOOP AT lt_rfc_method INTO ls_rfc_method.
    CLEAR ls_out_method.
    ls_out_method-CLSNAME = lv_badi_impl_name.
    ls_out_method-CMPNAME = ls_rfc_method.
    APPEND ls_out_method TO out_method_tab.
  ENDLOOP.
endmethod.

method CHECK_POST_LOOP_CLEAR.
  " 0 means do not have POST CLEAR
  " 1 means have
  DATA:
        ls_line_pool LIKE LINE OF lt_working_pool,
        lv_index TYPE i,
        lv_has_clear TYPE i,
        lv_bottom_range TYPE i,
        lv_loop_level TYPE i VALUE 0.

   lv_index = in_current_line.
   WHILE lv_index < in_bottom_range.
      READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
      FIND /SF0A0001/BADI_INTERFACE=>C_CLEAR IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         CALL METHOD has_clear_statement
           EXPORTING
              in_bottom_range = in_bottom_range
              in_current_line = in_current_line
           IMPORTING
              out_result = lv_has_clear.
         IF lv_has_clear = 1.
            out_result = 1.
            RETURN.
         ENDIF.
      ENDIF.
      lv_index = lv_index + 1.
   ENDWHILE.

   out_result = 0.
endmethod.

method FILL_EMAIL_ADDRESS.
  DATA: lt_table TYPE TABLE OF /SF0A0001/MAIL,
        ls_entry TYPE /SF0A0001/MAIL.

  SELECT * FROM /SF0A0001/MAIL INTO CORRESPONDING FIELDS OF TABLE lt_table.
  IF sy-subrc = 4.
     lv_email_address = 'jerry.wang@sap.com'.
     RETURN.
  ENDIF.
  READ TABLE lt_table INTO ls_entry WITH KEY USERNAME = sy-uname.
  IF sy-subrc = 4.
     lv_email_address = 'jerry.wang@sap.com'.
     RETURN.
  ENDIF.
  lv_email_address = ls_entry-mail.

endmethod.

method GET_INUMBER.
  DATA: SNC TYPE BAPISNCU,
        PNAME TYPE STRING,
        lv_offset TYPE i,
        R1 TYPE STANDARD TABLE OF BAPIRET2.
  CALL FUNCTION 'BAPI_USER_GET_DETAIL'
     EXPORTING
       USERNAME = sy-uname
     IMPORTING
       SNC = SNC
     TABLES
       RETURN  = R1.
  PNAME = snc-PNAME.
  IF PNAME IS INITIAL.
     MESSAGE e016(/SF0A0001/BADI_INSPE) WITH sy-uname.
  ENDIF.
  FIND 'CN=' IN PNAME MATCH OFFSET lv_offset.
  IF sy-subrc <> 0.
     MESSAGE e016(/SF0A0001/BADI_INSPE) WITH sy-uname.
  ENDIF.

  IF lv_offset <= 0.
     MESSAGE e016(/SF0A0001/BADI_INSPE) WITH sy-uname.
  ENDIF.
  lv_offset = lv_offset + 3.
  out_inumber = pname+lv_offset(7).
endmethod.

method GET_SOURCE_CODE_RFC.

 TYPES: line TYPE char255.
 TYPES: lt_line TYPE STANDARD TABLE OF line.
 DATA: lt_temp_line TYPE lt_line.
 CALL FUNCTION '/SF0A0006/GET_SOURCE_CODE' DESTINATION lv_destination
   EXPORTING
     IN_METHOD_NAME = in_method_name
     IN_CLASS_NAME = in_class_name
   CHANGING
     source_tab = lt_temp_line.

 CLEAR: lt_working_source.
 lt_working_source = lt_temp_line.

endmethod.

method LOG_WITH_TEXT.
   CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = in_text.
endmethod.

method POPULATE_FILE_PATH.
   DATA: inumber TYPE string.
   get_inumber( IMPORTING out_inumber = inumber ).
   out_path = 'C:and Settings_&& inumber && '_&& lv_local_file_name. "#EC NOTEXT

endmethod.
_
method SEND_MAIL.
DATA:
      lv_subject TYPE STRING,
      ls_docdata        TYPE souts_docdata,
      ls_send_data       TYPE souts_senddata,
      ls_recipient TYPE SOUTS_ERECP,
      ls_recipients     TYPE  souts_recp,
      lv_REQUEST_IDS  TYPE SOUTTT_REQID,
      lv_TARGETS_WITH_ERROR TYPE SOUTTT_RECEXC,
      lx_output_service TYPE REF TO CX_OUTPUT_SERVICE,
      lv_text TYPE string,
      lv_error TYPE string.

CHECK lv_pdf IS NOT INITIAL.

lv_subject                 = 'Badi Inspector Check Result'. "#EC NOTEXT
ls_recipient-mail_address  = lv_email_address.
APPEND ls_recipient TO ls_recipients-e_recipients.

ls_docdata-TYPE            = 'PDF'.
ls_docdata-TITLE           = 'CheckResult'.
ls_docdata-CONTENT_BIN = lv_pdf.
ls_send_data-sender-mail_address         = 'jerry.wang@sap.com'.

TRY.
    lv_text = 'Sending Mail to: ' && ls_recipient-mail_address && '...'. "#EC NOTEXT
     CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = lv_text.
    CL_OUTPUT_SERVICE=>DOCUMENT_OUTPUT(
      EXPORTING
        IP_OUTPUT_IMMEDIATELY   = 'X'
        IP_SUBJECT              = lv_SUBJECT
        IS_RECIPIENTS           = ls_recipients
        IS_DOCDATA              = ls_docdata
        IS_SEND_DATA            = ls_send_data
      IMPORTING
        ET_REQUEST_IDS          = lv_REQUEST_IDS
        ET_TARGETS_WITH_ERROR   = lv_TARGETS_WITH_error
        ).
  CATCH CX_OUTPUT_SERVICE INTO lx_output_service.
     lv_error = lx_output_service->get_text( ).
     MESSAGE lv_error TYPE 'E'.
ENDTRY.
COMMIT WORK AND WAIT.
endmethod.

method SEND_MAIL.
DATA:
      lv_subject TYPE STRING,
      ls_docdata        TYPE souts_docdata,
      ls_send_data       TYPE souts_senddata,
      ls_recipient TYPE SOUTS_ERECP,
      ls_recipients     TYPE  souts_recp,
      lv_REQUEST_IDS  TYPE SOUTTT_REQID,
      lv_TARGETS_WITH_ERROR TYPE SOUTTT_RECEXC,
      lx_output_service TYPE REF TO CX_OUTPUT_SERVICE,
      lv_text TYPE string,
      lv_error TYPE string.

CHECK lv_pdf IS NOT INITIAL.

lv_subject                 = 'Badi Inspector Check Result'. "#EC NOTEXT
ls_recipient-mail_address  = lv_email_address.
APPEND ls_recipient TO ls_recipients-e_recipients.

ls_docdata-TYPE            = 'PDF'.
ls_docdata-TITLE           = 'CheckResult'.
ls_docdata-CONTENT_BIN = lv_pdf.
ls_send_data-sender-mail_address         = 'jerry.wang@sap.com'.

TRY.
    lv_text = 'Sending Mail to: ' && ls_recipient-mail_address && '...'. "#EC NOTEXT
     CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = lv_text.
    CL_OUTPUT_SERVICE=>DOCUMENT_OUTPUT(
      EXPORTING
        IP_OUTPUT_IMMEDIATELY   = 'X'
        IP_SUBJECT              = lv_SUBJECT
        IS_RECIPIENTS           = ls_recipients
        IS_DOCDATA              = ls_docdata
        IS_SEND_DATA            = ls_send_data
      IMPORTING
        ET_REQUEST_IDS          = lv_REQUEST_IDS
        ET_TARGETS_WITH_ERROR   = lv_TARGETS_WITH_error
        ).
  CATCH CX_OUTPUT_SERVICE INTO lx_output_service.
     lv_error = lx_output_service->get_text( ).
     MESSAGE lv_error TYPE 'E'.
ENDTRY.
COMMIT WORK AND WAIT.
endmethod.

method GENERATE_PDF.
  DATA: ls_function TYPE rs38l_fnam,
        ls_options  TYPE ssfcompop,
        ls_control  TYPE ssfctrlop,
        lf_formname TYPE fpname,
        W_CX_ROOT   TYPE REF TO CX_ROOT,
        fp_interfacetype TYPE fpinterfacetype,
        fp_outputparams  TYPE sfpoutputparams,
        fp_docparams     TYPE sfpdocparams,
        ls_fp_result     TYPE fpformoutput,
        lt_input         TYPE /SF0A0001/T_BADI,
        ls_error_log     LIKE LINE OF lt_error_log,
        ls_input         LIKE LINE OF lt_input,
        lv_text          TYPE string,
        MESG TYPE string.

  CHECK lt_error_log IS NOT INITIAL.

  lf_formname = '/SF0A0001/PF_BADI_LOG'.
  TRY.
     lv_text = 'Getting Function Module for: ' && lf_formname && '...'. "#EC NOTEXT
     CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = lv_text.
     CALL FUNCTION 'FP_FUNCTION_MODULE_NAME'
        EXPORTING
          i_name               = lf_formname
        IMPORTING
          e_funcname           = ls_function
          e_interface_type     = fp_interfacetype.
     CATCH CX_ROOT INTO W_CX_ROOT.
        MESG = W_CX_ROOT->GET_TEXT( ).
        MESSAGE e013(/SF0A0001/BADI_INSPE) WITH MESG lf_formname.
  ENDTRY.

  IF sy-subrc <> 0.
     MESSAGE e013(/SF0A0001/BADI_INSPE) WITH MESG sy-subrc.
  ENDIF.

  fp_outputparams-nodialog = abap_true.
  fp_outputparams-noprint = abap_false.
  fp_outputparams-getpdf = abap_true.

  lv_text = 'Opening Job...'.  "#EC NOTEXT
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
      EXPORTING
        TEXT = lv_text.

  CALL FUNCTION 'FP_JOB_OPEN'
    CHANGING
      ie_outputparams = fp_outputparams
    EXCEPTIONS
      cancel          = 1
      usage_error     = 2
      system_error    = 3
      internal_error  = 4
      OTHERS          = 5.
  IF sy-subrc <> 0.
    MESSAGE e014(/SF0A0001/BADI_INSPE) WITH sy-subrc.
  ENDIF.
  CLEAR: fp_docparams.

  fp_docparams-fillable = abap_false.

  LOOP AT lt_error_log INTO ls_error_log.
     MOVE-CORRESPONDING ls_error_log TO ls_input.
     APPEND ls_input TO lt_input.
  ENDLOOP.

  lv_text = 'Generating PDF...'.  "#EC NOTEXT
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
      EXPORTING
        TEXT = lv_text.

  CALL FUNCTION ls_function
    EXPORTING
        /1bcdwb/docparams = fp_docparams
        error_log = lt_input
        user_name = sy-uname
        work_mode = lv_work_mode
    IMPORTING
      /1bcdwb/formoutput = ls_fp_result.

  lv_pdf = ls_fp_result-PDF.
endmethod.

method PRE_HANDLE_ENTRY.
  SORT lt_import_tab.
  DELETE ADJACENT DUPLICATES FROM lt_import_tab.
endmethod.

method SEARCH_IMPORT.
   DATA: lv_index TYPE i,
         lv_is_import TYPE i,
         lv_result TYPE i,
         ls_line_pool LIKE LINE OF lt_working_pool.

   lv_index = in_current_line.
   lv_is_import = 0.
   WHILE lv_index > 1.
      READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
      FIND /SF0A0001/BADI_INTERFACE=>C_IMPORT IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         lv_is_import = 1.
      ENDIF.
      FIND lv_current_variable IN ls_line_pool-line_text.
      IF sy-subrc = 0 AND ls_line_pool-line_num = in_data_define_line.
      " reach the data definition but still NO CLEAR found
         _FIND_CLEAR_IMPORT_TAB( EXPORTING in_current_line = in_current_line ).
        RETURN.
      ENDIF.
      IF sy-subrc = 0 AND ls_line_pool-line_num = in_current_line.
         lv_index = lv_index - 1.
         lv_is_import = 1.
         CONTINUE.
      ENDIF.
      IF sy-subrc = 0 AND lv_is_import = 1.
      " find the variable again and it is really a importing, not clear
         " error reporting
        CALL METHOD HAS_CLEAR_STATEMENT
          EXPORTING
            in_current_line = ls_line_pool-line_num
          IMPORTING
            out_result = lv_result.
        IF lv_result = 0.
           _FIND_CLEAR_IMPORT_TAB( EXPORTING in_current_line = in_current_line ).
        ENDIF.
        RETURN.
      ENDIF.
      IF sy-subrc = 0 AND lv_is_import = 0.
         " the 4th situation, normal assignment operation
         RETURN.
      ENDIF.
      FIND /SF0A0001/BADI_INTERFACE=>C_CLEAR IN ls_line_pool-line_text.
      IF sy-subrc <> 0.
         lv_index = lv_index - 1.
         CONTINUE.
      ENDIF.
      CALL METHOD HAS_CLEAR_STATEMENT
        EXPORTING
          in_current_line = ls_line_pool-line_num
        IMPORTING
          out_result = lv_result.
      IF lv_result = 1.
        RETURN.
      ENDIF.
      lv_index = lv_index - 1.

   ENDWHILE.

   " CLEAR not find, most possiblely that current importing appears below
   " another importing.
   _FIND_CLEAR_IMPORT_TAB( EXPORTING in_current_line = in_current_line ).
endmethod.

method LOG.
  DATA : lv_text TYPE string.

  lv_text = 'Checking: ' && lv_current_variable &&
   ' in Badi/Post Exit: ' && lv_badi_impl_name && ' Method: ' && lv_current_method. "#EC NOTEXT
  CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
        EXPORTING
          TEXT = lv_text.
endmethod.

method _FIND_CLEAR_IMPORT_TAB.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lv_in_loop TYPE i,
        lv_top_range TYPE i,
        lv_bottom_range TYPE i,
        lv_result TYPE i,
        ls_error_log TYPE ty_error_log.

  " the last step to check post clear OPERATION!
  CALL METHOD has_loop
     EXPORTING
        in_current_line = in_current_line
     IMPORTING
        out_result = lv_in_loop
        out_top_range = lv_top_range
        out_bottom_range = lv_bottom_range.
  IF lv_in_loop = 0.
      RETURN.
  ENDIF.
  CALL METHOD check_post_loop_clear
     EXPORTING
       in_current_line = in_current_line
       in_bottom_range = lv_bottom_range
     IMPORTING
       out_result = lv_result.
  IF lv_result = 1.
     RETURN.
  ENDIF.
  READ TABLE lt_working_pool INTO ls_item INDEX in_current_line.
  IF lv_first_error = 0.
     lv_first_error = 1.
     CLEAR ls_error_log.
     ls_error_log-class_name = lv_badi_impl_name.
  ENDIF.

  ls_error_log-method_name = lv_current_method.
  ls_error_log-author = lv_author.
  ls_error_log-error_type = '@09@'.
  ls_error_log-error_line = in_current_line.
  ls_error_log-error_text = ls_item-line_text.
  ls_error_log-description = 'Variable Must be Clear Before Using it As Importing Parameter.'. "#EC NOTEXT
  APPEND ls_error_log TO lt_error_log.
endmethod.

method HAS_LOOP.
   DATA:
        ls_line_pool LIKE LINE OF lt_working_pool,
        lv_index TYPE i,
        lv_top_range TYPE i,
        lv_bottom_range TYPE i,
        lv_loop_level TYPE i VALUE 0,
        lv_max_line TYPE i,
        line_length TYPE i.
   " 0 means do not have ;
   " 1 mean have

   lv_index = in_current_line.
   lv_max_line = lines( lt_working_pool ).
   WHILE lv_index > 1.
      READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
      FIND /SF0A0001/BADI_INTERFACE=>C_METHOD_END IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         EXIT.
      ENDIF.
      line_length = strlen( ls_line_pool-line_text ).
      IF line_length = 0.
         lv_index = lv_index - 1.
         CONTINUE.
      ENDIF.

      IF ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT OR
         ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
         lv_index = lv_index - 1.
         CONTINUE.
      ENDIF.

      FIND /SF0A0001/BADI_INTERFACE=>C_LOOPEND IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         lv_loop_level = lv_loop_level - 1.
         lv_index = lv_index - 1.
         CONTINUE.
      ENDIF.
      FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         lv_loop_level = lv_loop_level + 1.
         lv_index = lv_index - 1.
         lv_top_range = ls_line_pool-line_num.
         CONTINUE.
      ENDIF.
      lv_index = lv_index - 1.
   ENDWHILE.

   IF lv_loop_level <= 0.
      out_result = 0.
      RETURN.
   ENDIF.

   lv_index = in_current_line.
   WHILE lv_loop_level <> 0 AND lv_index <= lv_max_line.
      READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
      FIND /SF0A0001/BADI_INTERFACE=>C_LOOPEND IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         lv_loop_level = lv_loop_level - 1.
         lv_index = lv_index + 1.
         lv_bottom_range = ls_line_pool-line_num.
         CONTINUE.
      ENDIF.

      FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         lv_loop_level = lv_loop_level + 1.
         lv_index = lv_index + 1.
         CONTINUE.
      ENDIF.

      lv_index = lv_index + 1.
   ENDWHILE.
   out_result = 1.
   ASSERT lv_top_range <= in_current_line.
   ASSERT lv_bottom_range >= in_current_line.
   out_top_range = lv_top_range.
   out_bottom_range = lv_bottom_range.
endmethod.

method HAS_CLEAR_STATEMENT.

   " find between current line and max line to check
   " whether there is CLEAR between them.
   DATA:
        ls_line_pool LIKE LINE OF lt_working_pool,
        lv_index TYPE i,
        lv_max_line TYPE i.

   lv_max_line = lines( lt_working_pool ).
   ASSERT in_bottom_range <= lv_max_line.
   IF in_bottom_range IS SUPPLIED.
      ASSERT in_bottom_range > 1.
      lv_max_line = in_bottom_range.
   ENDIF.
   lv_index = in_current_line.
   WHILE lv_index < lv_max_line.
      READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
      " find variable is priority 1
      FIND lv_current_variable IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         out_result = 1.
         RETURN.
      ENDIF.
      FIND /SF0A0001/BADI_INTERFACE=>C_END IN ls_line_pool-line_text.
      IF sy-subrc = 0.
         out_result = 0.
         RETURN.
      ENDIF.
      lv_index = lv_index + 1.
   ENDWHILE.

   out_result = 0.
endmethod.

method FIND_IMPORT_TAB.
   DATA:
        ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_index TYPE i,
        lv_max_line TYPE i,
        ls_error_log TYPE ty_error_log.

   lv_index = in_current_line.
   IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR
      lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.
      DO /SF0A0001/BADI_INTERFACE=>C_IMPORT_LEVEL_UPWARD TIMES.
        READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
        IF  sy-subrc <> 0.
           EXIT.
        ENDIF.
        FIND /SF0A0001/BADI_INTERFACE=>C_METHODS IN ls_line_pool-line_text.
           IF sy-subrc = 0.
              RETURN.
           ENDIF.
        lv_index = lv_index - 1.
      ENDDO.
   ENDIF.

   CLEAR ls_line_pool.
   lv_max_line = in_current_line + /SF0A0001/BADI_INTERFACE=>C_IMPORT_LEVEL_DOWNWARD.
   lv_index = in_current_line.
   WHILE lv_index < lv_max_line.
     READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
     line_length = strlen( ls_line_pool-line_text ).
     IF line_length = 0.
        lv_index = lv_index + 1.
        CONTINUE.
     ENDIF.
     IF ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT.
        lv_index = lv_index + 1.
        CONTINUE.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_END IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        fill_import_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
        RETURN.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_EQUAL IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        fill_import_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
        RETURN.
     ENDIF.
     lv_index = lv_index + 1.
   ENDWHILE.

   ASSERT 1 = 0.

endmethod.

method FILL_IMPORT_TAB.
  DATA: ls_line LIKE LINE OF lt_working_pool,
        lv_tab TYPE string,
        lv_temp TYPE string,
        lt_string_tab TYPE string_table.

  READ TABLE lt_working_pool INTO ls_line INDEX in_current_line.
  SPLIT ls_line-line_text AT SPACE INTO TABLE lt_string_tab.
  CALL METHOD PACK_STRING_TABLE
          CHANGING
             c_string_table = lt_string_tab.
  LOOP AT lt_string_tab INTO lv_temp.
     IF lv_temp = /SF0A0001/BADI_INTERFACE=>C_EQUAL.
        READ TABLE lt_string_tab INTO lv_tab INDEX ( sy-tabix + 1 ).
        EXIT.
     ENDIF.
  ENDLOOP.
  IF lv_tab IS INITIAL.
     ASSERT 1 = 0.
  ENDIF.
  IF lv_tab  CA '.'.
     REPLACE ALL OCCURRENCES OF '.' IN lv_tab WITH SPACE.
     CONDENSE lv_tab NO-GAPS.
  ENDIF.
  APPEND lv_tab TO lt_import_tab.

endmethod.
method CONTAINS_ONLY.
  DATA: lv_offset TYPE i,
        start TYPE i,
        total TYPE i,
        postfix TYPE c.

  FIND lv_current_variable IN in_line_text MATCH OFFSET lv_offset.
  start = strlen( lv_current_variable ).
  total = strlen( in_line_text ).
  start = start + lv_offset.
  IF start = total.
     out_result = 1.
     RETURN.
  ENDIF.
  postfix = in_line_text+start(1).
  CASE postfix.
     WHEN /SF0A0001/BADI_INTERFACE=>C_END.
       out_result = 1.
     WHEN /SF0A0001/BADI_INTERFACE=>C_EQUAL.
       out_result = 1.
     WHEN /SF0A0001/BADI_INTERFACE=>C_QUOTA.
       out_result = 1.
     WHEN /SF0A0001/BADI_INTERFACE=>C_FIELD.
       out_result = 1.
     WHEN SPACE.
       out_result = 1.
     WHEN OTHERS.
       out_result = 0.
  ENDCASE.
endmethod.

method CHECK_TABLE_VARIABLE.
  " first check each variable, if it is reference variable, Kick it out!

  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        lv_tab_variable_define_line TYPE i,
        lv_result TYPE i,
        line_length TYPE i.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     FIND /SF0A0001/BADI_INTERFACE=>C_TYPE_DEFINITION IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND lv_current_variable IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_REFERENCE IN ls_line_pool-line_text.
     IF sy-subrc = 0. " current variable is a reference object
        RETURN.
     ENDIF.
     lv_tab_variable_define_line = ls_line_pool-line_num.
     EXIT.
  ENDLOOP.

  IF lv_tab_variable_define_line IS INITIAL.
     " (1) defined in the DATA: ** TYPE but never used ,
     " (2) member of class, to be checked in the future
     RETURN.
  ENDIF.


  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     FIND lv_current_variable IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     " LT_COMMON & LT_COMMON_TABLE ISSUE
     CALL METHOD CONTAINS_ONLY
       EXPORTING
         in_line_text = ls_line_pool-line_text
       RECEIVING
         out_result   = lv_result.
     CHECK lv_result = 1.
     CHECK ls_line_pool-line_num <> lv_tab_variable_define_line.
     FIND /SF0A0001/BADI_INTERFACE=>C_CLEAR IN ls_line_pool-line_text.
     " we can not simply consider that once find CLEAR : lt_link, it needen't be checked,
     " becasue it may occurance in many places.
     CHECK sy-subrc <> 0.
     " find variable occurance, handle with 4 kinds of situation
     SEARCH_IMPORT( EXPORTING in_current_line = ls_line_pool-line_num IN_DATA_DEFINE_LINE = lv_tab_variable_define_line ).
  ENDLOOP.
endmethod.

method CHECK_CLEAR_IMPORT_TAB.

  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.

  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_upper_range TYPE i,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method,
        lv_class TYPE SEOCLSKEY.

  lv_class-CLSNAME = lv_badi_impl_name.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
     FIND /SF0A0001/BADI_INTERFACE=>C_IMPORT IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_CONSTRUCTOR IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        CONTINUE.
     ENDIF.
     find_import_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
  ENDLOOP.

  pre_handle_entry( ).

  LOOP AT lt_import_tab INTO lv_current_variable.
     log( ).
     IF sy-tabix > 22.
        BREAK-POINT.
     ENDIF.
     check_table_variable( ).
  ENDLOOP.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.
     RETURN.
  ENDIF.

  IF lv_rfc_mode = 1.
     CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>get_method_rfc
        EXPORTING
          in_class_name = lv_class-CLSNAME
        IMPORTING
          out_method_tab = lt_method.
  ELSE.
    CALL FUNCTION 'SEO_METHOD_READ_ALL'
      EXPORTING
         CIFKEY = lv_class
      IMPORTING
         methods = lt_method.
  ENDIF.
  lv_in_method = 1.
  LOOP AT lt_method INTO ls_method.
     CLEAR: method_key,lt_working_source,lt_import_tab,lv_current_method.
     method_key-CLSNAME = lv_badi_impl_name.
     method_key-CPDNAME = ls_method-CMPname.
     IF lv_rfc_mode = 1.
       CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
         EXPORTING
           MTDKEY = method_key
         IMPORTING
           SOURCE_expanded = lt_working_source.
     ELSE.
       CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
         EXPORTING
           MTDKEY = method_key
         IMPORTING
           SOURCE_expanded = lt_working_source.
     ENDIF.
     lv_current_method = ls_method-CMPname.
     FILL_SOURCE_TABLE( ).
     LOOP AT lt_working_pool INTO ls_line_pool.
       line_length = strlen( ls_line_pool-line_text ).
       CHECK line_length > 0.
       CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
       CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
       FIND /SF0A0001/BADI_INTERFACE=>C_IMPORT IN ls_line_pool-line_text.
       CHECK sy-subrc = 0.
       find_import_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
     ENDLOOP.

     pre_handle_entry( ).

     LOOP AT lt_import_tab INTO lv_current_variable.
       log( ).
       check_table_variable( ).
     ENDLOOP.
  ENDLOOP.

endmethod.

method CHECK_READ_TABLE.
  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.

  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_upper_range TYPE i,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method,
        lv_class TYPE SEOCLSKEY.

  lv_class-CLSNAME = lv_badi_impl_name.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
     FIND /SF0A0001/BADI_INTERFACE=>C_READ IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_TABLE IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     " fill issue by Ian: must also check IS ASSIGNED.
     FIND /SF0A0001/BADI_INTERFACE=>C_TABLE_ASSIGN IN ls_line_pool-line_text.
     IF sy-subrc <> 0.
        _find_subrc( EXPORTING in_current_line = ls_line_pool-line_num ).
     ELSE.
        _find_assigned_in_table_read( EXPORTING in_current_line = ls_line_pool-line_num ).
     ENDIF.
  ENDLOOP.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.
     RETURN.
  ENDIF.

  IF lv_rfc_mode = 1.
    CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>get_method_rfc
        EXPORTING
          in_class_name = lv_class-CLSNAME
        IMPORTING
          out_method_tab = lt_method.
  ELSE.
    CALL FUNCTION 'SEO_METHOD_READ_ALL'
      EXPORTING
         CIFKEY = lv_class
      IMPORTING
         methods = lt_method.
  ENDIF.

  LOOP AT lt_method INTO ls_method.
    CLEAR: method_key,lt_working_source,lt_field_symbol_tab.
    method_key-CLSNAME = lv_badi_impl_name.
    method_key-CPDNAME = ls_method-CMPname.
    IF lv_rfc_mode = 1.
      CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
        EXPORTING
          MTDKEY = method_key
        IMPORTING
          SOURCE_expanded = lt_working_source.
    ELSE.
     CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
        EXPORTING
          MTDKEY = method_key
        IMPORTING
          SOURCE_expanded = lt_working_source.
    ENDIF.
    lv_current_method = ls_method-CMPname.
    FILL_SOURCE_TABLE( ).
    LOOP AT lt_working_pool INTO ls_line_pool.
      line_length = strlen( ls_line_pool-line_text ).
      CHECK line_length > 0.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
      FIND /SF0A0001/BADI_INTERFACE=>C_READ IN ls_line_pool-line_text.
      CHECK sy-subrc = 0.
      FIND /SF0A0001/BADI_INTERFACE=>C_TABLE IN ls_line_pool-line_text.
      CHECK sy-subrc = 0.
      FIND /SF0A0001/BADI_INTERFACE=>C_TABLE_ASSIGN IN ls_line_pool-line_text.
      IF sy-subrc <> 0.
        _find_subrc( EXPORTING in_current_line = ls_line_pool-line_num ).
      ELSE.
        _find_assigned_in_table_read( EXPORTING in_current_line = ls_line_pool-line_num ).
      ENDIF.
    ENDLOOP.

  ENDLOOP.
endmethod.

method _FIND_SUBRC.
  DATA: lv_current_index TYPE i,
        ls_line_pool LIKE LINE OF lt_working_pool,
        lt_string_table TYPE string_table,
        ls_error_log TYPE ty_error_log,
        lv_max_line TYPE i,
        line_length TYPE i.

  lv_max_line = in_current_line + /SF0A0001/BADI_INTERFACE=>C_READ_SUBRC_LEVEL_DOWNWARD.
  lv_current_index = in_current_line.
  WHILE lv_current_index < lv_max_line.
     READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_current_index.
     line_length = strlen( ls_line_pool-line_text ).
     IF line_length = 0 OR ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT
        OR ls_line_pool-line_text+0(1) = /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
        lv_current_index = lv_current_index + 1.
        CONTINUE.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_SYSTEM_RETURN IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     " IS ls*** IS NOT INITIAL.
     FIND /SF0A0001/BADI_INTERFACE=>C_REFER_CHECK IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     lv_current_index = lv_current_index + 1.
  ENDWHILE.

  CLEAR ls_line_pool.
  READ TABLE lt_working_pool INTO ls_line_pool INDEX in_current_line.
  IF lv_first_error = 0.
     lv_first_error = 1.
     CLEAR ls_error_log.
     ls_error_log-class_name = lv_badi_impl_name.
  ENDIF.
  ls_error_log-error_type = '@09@'.
  ls_error_log-error_line = ls_line_pool-line_num.
  ls_error_log-error_text = ls_line_pool-line_text.
  "ls_error_log-class_name = lv_badi_impl_name.
  ls_error_log-method_name = lv_current_method.
  ls_error_log-author = lv_author.
  ls_error_log-description = 'Check sy-subrc to make sure Read is successful'.  "#EC NOTEXT
  APPEND ls_error_log TO lt_error_log.

endmethod.

method CHECK_REFER_VARIABLE.
  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_upper_range TYPE i,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method,
        lv_class TYPE SEOCLSKEY.

  lv_class-CLSNAME = lv_badi_impl_name.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
     FIND /SF0A0001/BADI_INTERFACE=>C_REFERENCE IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     fill_reference_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
  ENDLOOP.

  LOOP AT lt_reference_tab INTO lv_current_variable.
    log( ).
    scan_refer_variable( ).
  ENDLOOP.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.
     RETURN.
  ENDIF.

  IF lv_rfc_mode = 1.
     CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>get_method_rfc
        EXPORTING
          in_class_name = lv_class-CLSNAME
        IMPORTING
          out_method_tab = lt_method.
  ELSE.
    CALL FUNCTION 'SEO_METHOD_READ_ALL'
      EXPORTING
         CIFKEY = lv_class
      IMPORTING
         methods = lt_method.
  ENDIF.

  LOOP AT lt_method INTO ls_method.
    CLEAR: method_key,lt_working_source,lt_reference_tab.
    method_key-CLSNAME = lv_badi_impl_name.
    method_key-CPDNAME = ls_method-CMPname.
    IF lv_rfc_mode = 1.
      CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
        EXPORTING
          MTDKEY = method_key
        IMPORTING
          SOURCE_expanded = lt_working_source.
    ELSE.
     CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
        EXPORTING
          MTDKEY = method_key
        IMPORTING
          SOURCE_expanded = lt_working_source.
    ENDIF.
    lv_current_method = ls_method-CMPname.
    FILL_SOURCE_TABLE( ).
    LOOP AT lt_working_pool INTO ls_line_pool.
      line_length = strlen( ls_line_pool-line_text ).
      CHECK line_length > 0.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
      FIND /SF0A0001/BADI_INTERFACE=>C_REFERENCE IN ls_line_pool-line_text.
      CHECK sy-subrc = 0.
      fill_reference_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
    ENDLOOP.

    LOOP AT lt_reference_tab INTO lv_current_variable.
      log( ).
      scan_refer_variable( ).
    ENDLOOP.

  ENDLOOP.
endmethod.

method FILL_REFERENCE_TAB.
  DATA:
        ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_formatted TYPE string.


  READ TABLE lt_working_pool INTO ls_line_pool INDEX in_current_line.
  my_condense( EXPORTING in_string = ls_line_pool-line_text IMPORTING out_string = lv_formatted ).
  FIND /SF0A0001/BADI_INTERFACE=>C_REFERENCE_TO IN ls_line_pool-line_text.
  IF sy-subrc <> 0.
     RETURN.
  ENDIF.
  SPLIT ls_line_pool-line_text AT SPACE INTO TABLE lt_string_table.
  CALL METHOD PACK_STRING_TABLE
     CHANGING
         c_string_table = lt_string_table.
  FETCH_VARIABLE_NAME( EXPORTING in_string_table = lt_string_table ).
  APPEND lv_current_variable TO lt_reference_tab.

endmethod.

method MY_CONDENSE.
  DATA: lt_temp TYPE string_table,
        ls_result TYPE string,
        ls_temp TYPE string.

  SPLIT in_string AT SPACE INTO TABLE lt_temp.
  LOOP AT lt_temp INTO ls_temp.
     ls_result = ls_result && ls_temp.
  ENDLOOP.

  out_string = ls_result.
endmethod.

method _FIND_REF_CHECK_STATEMENT.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_index TYPE i,
        lv_max_line TYPE i,
        ls_error_log TYPE ty_error_log.

   lv_max_line = lines( lt_working_pool ).
   lv_index = in_current_line + 1.
   WHILE lv_index < lv_max_line.
     READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
     IF sy-subrc <> 0.
        MESSAGE e010(/SF0A0001/BADI_INSPE) WITH lv_current_variable.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_REFER_CHECK IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_SYSTEM_RETURN IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     FIND lv_current_variable IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
        IF sy-subrc = 0.
           RETURN.
        ENDIF.
        IF lv_first_error = 0.
          lv_first_error = 1.
          CLEAR ls_error_log.
          ls_error_log-class_name = lv_badi_impl_name.
        ENDIF.
        ls_error_log-error_type = '@0A@'.
        ls_error_log-error_line = ls_line_pool-line_num.
        ls_error_log-error_text = ls_line_pool-line_text.
        "ls_error_log-class_name = lv_badi_impl_name.
        ls_error_log-method_name = lv_current_method.
        ls_error_log-author = lv_author.
        ls_error_log-description = 'Check reference variable before using it'.  "#EC NOTEXT
        APPEND ls_error_log TO lt_error_log.
        RETURN.
     ENDIF.
     lv_index = lv_index + 1.
   ENDWHILE.

   ASSERT 1 = 0.
endmethod.

method SCAN_REFER_VARIABLE.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_backup_error_line TYPE string,
        lv_backup_error_num TYPE string,
        ls_error_log TYPE ty_error_log.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
     CHECK sy-subrc <> 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_REFER_ASSIGN IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND lv_current_variable IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.

     _find_ref_check_statement( EXPORTING in_current_line = ls_line_pool-line_num ).
     RETURN.
  ENDLOOP.
endmethod.

method CHECK_FIELD_SYMBOL.

  TYPE-POOLS seoo.
  TYPE-POOLS seoc.
  TYPE-POOLS seop.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_upper_range TYPE i,
        lt_method TYPE SEOO_METHODS_R,
        method_key TYPE SEOCPDKEY,
        ls_method LIKE LINE OF lt_method,
        lv_class TYPE SEOCLSKEY.

  lv_class-CLSNAME = lv_badi_impl_name.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
     FIND /SF0A0001/BADI_INTERFACE=>C_FIELD_SYMBOL IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     fill_field_symbol_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
  ENDLOOP.

  LOOP AT lt_field_symbol_tab INTO lv_current_variable.
    log( ).
    scan_field_symbol( ).
  ENDLOOP.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_SINGLE OR lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_POST_EXIT_MASS.
     RETURN.
  ENDIF.

  IF lv_rfc_mode = 1.
     CALL METHOD /SF0A0001/BADI_CODE_INSPECTOR=>get_method_rfc
        EXPORTING
          in_class_name = lv_class-CLSNAME
        IMPORTING
          out_method_tab = lt_method.
  ELSE.
     CALL FUNCTION 'SEO_METHOD_READ_ALL'
       EXPORTING
         CIFKEY = lv_class
       IMPORTING
         methods = lt_method.
  ENDIF.
  LOOP AT lt_method INTO ls_method.
    CLEAR: method_key,lt_working_source,lt_field_symbol_tab.
    method_key-CLSNAME = lv_badi_impl_name.
    method_key-CPDNAME = ls_method-CMPname.
    IF lv_rfc_mode = 1.
      CALL METHOD GET_SOURCE_CODE_RFC
        EXPORTING
          in_class_name = method_key-CLSNAME
          in_method_name = method_key-CPDNAME.
    ELSE.
      CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
        EXPORTING
          MTDKEY = method_key
        IMPORTING
          SOURCE_expanded = lt_working_source.
    ENDIF.
    lv_current_method = ls_method-CMPname.
    FILL_SOURCE_TABLE( ).
    LOOP AT lt_working_pool INTO ls_line_pool.
      line_length = strlen( ls_line_pool-line_text ).
      CHECK line_length > 0.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
      CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
      FIND /SF0A0001/BADI_INTERFACE=>C_FIELD_SYMBOL IN ls_line_pool-line_text.
      CHECK sy-subrc = 0.
      fill_field_symbol_tab( EXPORTING in_current_line = ls_line_pool-line_num ).
    ENDLOOP.

    LOOP AT lt_field_symbol_tab INTO lv_current_variable.
      log( ).
      scan_field_symbol( ).
    ENDLOOP.

  ENDLOOP.
endmethod.

method FILL_FIELD_SYMBOL_TAB.
DATA:   ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_index TYPE i,
        lv_max_line TYPE i.

lv_max_line = lines( lt_working_pool ).
lv_index = in_current_line.

WHILE lv_index < lv_max_line.
  READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
  FIND /SF0A0001/BADI_INTERFACE=>C_TYPE_DEFINITION IN ls_line_pool-line_text.
  IF sy-subrc <> 0.
     lv_index = lv_index + 1.
     CONTINUE.
  ENDIF.
  SPLIT ls_line_pool-line_text AT SPACE INTO TABLE lt_string_table.
  CALL METHOD PACK_STRING_TABLE
     CHANGING
         c_string_table = lt_string_table.
  FETCH_VARIABLE_NAME( EXPORTING in_string_table = lt_string_table ).
  APPEND lv_current_variable TO lt_field_symbol_tab.
  FIND /SF0A0001/BADI_INTERFACE=>C_END IN ls_line_pool-line_text.
  IF sy-subrc = 0.
     RETURN.
  ENDIF.
  lv_index = lv_index + 1.
ENDWHILE.

MESSAGE e009(/SF0A0001/BADI_INSPE).

endmethod.

method _FIND_FS_CHECK_STATEMENT.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_index TYPE i,
        lv_max_line TYPE i,
        ls_error_log TYPE ty_error_log.

   lv_max_line = lines( lt_working_pool ).
   lv_index = in_current_line + 1.
   WHILE lv_index < lv_max_line.
     READ TABLE lt_working_pool INTO ls_line_pool INDEX lv_index.
     IF sy-subrc <> 0.
        MESSAGE e010(/SF0A0001/BADI_INSPE) WITH lv_current_variable.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_FS_CHECK IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     FIND /SF0A0001/BADI_INTERFACE=>C_SYSTEM_RETURN IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     FIND lv_current_variable IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
        IF sy-subrc = 0.
           RETURN.
        ENDIF.
        IF lv_first_error = 0.
           lv_first_error = 1.
           CLEAR ls_error_log.
           ls_error_log-class_name = lv_badi_impl_name.
        ENDIF.

        ls_error_log-error_type = '@0A@'.
        ls_error_log-error_line = ls_line_pool-line_num.
        ls_error_log-error_text = ls_line_pool-line_text.
        "ls_error_log-class_name = lv_badi_impl_name.
        ls_error_log-method_name = lv_current_method.
        ls_error_log-author = lv_author.
        ls_error_log-description = 'Check field-symbol before using it'. "#EC NOTEXT
        APPEND ls_error_log TO lt_error_log.
        RETURN.
     ENDIF.
     lv_index = lv_index + 1.
   ENDWHILE.

   ASSERT 1 = 0.
endmethod.

method SCAN_FIELD_SYMBOL.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_output_request_call TYPE string,
        lv_backup_error_line TYPE string,
        lv_backup_error_num TYPE string,
        ls_error_log TYPE ty_error_log.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT.
     CHECK ls_line_pool-line_text+0(1) <> /SF0A0001/BADI_INTERFACE=>C_COMMENT1.
     FIND /SF0A0001/BADI_INTERFACE=>C_FIELD_ASSIGN IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND lv_current_variable IN ls_line_pool-line_text.
     CHECK sy-subrc = 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_LOOP IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        RETURN.
     ENDIF.
     _find_fs_check_statement( EXPORTING in_current_line = ls_line_pool-line_num ).
     RETURN.
  ENDLOOP.

endmethod.

method GET_AUTHOR.
  DATA: lt_badi_table TYPE TABLE OF TADIR,
        ls_item TYPE TADIR.

  IF lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_SINGLE OR
     lv_work_mode = /SF0A0001/BADI_INTERFACE=>C_BADI_MASS.
     SELECT AUTHOR FROM TADIR INTO CORRESPONDING FIELDS OF TABLE lt_badi_table
        WHERE PGMID = 'R3TR' AND OBJECT = 'CLAS' AND OBJ_NAME = lv_badi_impl_name.

     READ TABLE lt_badi_table INTO ls_item INDEX 1.
     lv_author = ls_item-author.
  ELSE.
     SELECT AUTHOR FROM TADIR INTO CORRESPONDING FIELDS OF TABLE lt_badi_table
        WHERE PGMID = 'R3TR' AND OBJECT = 'ENHO' AND OBJ_NAME = lv_badi_impl_name.

     READ TABLE lt_badi_table INTO ls_item INDEX 1.
     lv_author = ls_item-author.
  ENDIF.

endmethod.

method CHECK_OUTPUT_REQUEST.
  DATA: ls_line_pool LIKE LINE OF lt_working_pool,
        line_length TYPE i,
        lt_string_table TYPE string_table,
        lv_offset TYPE i,
        lv_output_request_call TYPE string,
        lv_upper_range TYPE i.

  LOOP AT lt_working_pool INTO ls_line_pool.
     line_length = strlen( ls_line_pool-line_text ).
     CHECK line_length > 0.
     FIND /SF0A0001/BADI_INTERFACE=>C_OUTPUT_REQUEST IN ls_line_pool-line_text MATCH OFFSET lv_offset.
     IF SY-SUBRC = 0.
       SPLIT ls_line_pool-line_text AT SPACE INTO TABLE lt_string_table.
       CALL METHOD PACK_STRING_TABLE
          CHANGING
             c_string_table = lt_string_table.
       FETCH_VARIABLE_NAME( EXPORTING in_string_table = lt_string_table ).
     ENDIF.

     CHECK lv_current_variable IS NOT INITIAL.
     CONCATENATE lv_current_variable '->' INTO lv_output_request_call.
     FIND lv_output_request_call IN ls_line_pool-line_text.
     IF sy-subrc = 0.
        find_upper_range( EXPORTING in_current_line = ls_line_pool-line_num
           RECEIVING upper_line = lv_upper_range ).
        _find_check_output_req( EXPORTING in_current_line = ls_line_pool-line_num
                                         in_upper_range = lv_upper_range ).
        RETURN.
     ENDIF.

  ENDLOOP.
endmethod.

method FETCH_VARIABLE_NAME.
  DATA: lv_string TYPE string,
        lv_hit TYPE i.

  CLEAR lv_current_variable.
  LOOP AT in_string_table INTO lv_string.
    IF lv_string = /SF0A0001/BADI_INTERFACE=>C_TYPE_DEFINITION.
       lv_hit = sy-tabix - 1.
       IF lv_hit <= 0 OR lv_hit > lines( in_string_table ).
           MESSAGE e001(/SF0A0001/BADI_INSPE) with lv_hit.
       ENDIF.
       READ TABLE in_string_table INTO lv_string INDEX lv_hit.
       CHECK sy-subrc = 0.
       lv_current_variable = lv_string.
    ENDIF.
  ENDLOOP.
  IF lv_current_variable IS INITIAL.
    ASSERT 1 = 0.
    MESSAGE e002(/SF0A0001/BADI_INSPE) WITH /SF0A0001/BADI_INTERFACE=>C_OUTPUT_REQUEST.
  ENDIF.
endmethod.

method _FIND_CHECK_OUTPUT_REQ.
  DATA: ls_item LIKE LINE OF lt_working_pool,
        lv_index TYPE i,
        ls_error_log TYPE ty_error_log.

  lv_index = in_upper_range.
  WHILE lv_index < in_current_line.
    READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
    FIND /SF0A0001/BADI_INTERFACE=>C_CHECK IN ls_item-line_text.
    IF sy-subrc = 0.
       FIND lv_current_variable IN ls_item-line_text.
       IF sy-subrc = 0.
          RETURN.
       ENDIF.
    ENDIF.
    lv_index = lv_index + 1.
  ENDWHILE.

  READ TABLE lt_working_pool INTO ls_item INDEX lv_index.
  IF lv_first_error = 0.
     lv_first_error = 1.
     CLEAR ls_error_log.
     ls_error_log-class_name = lv_badi_impl_name.

  ENDIF.

  ls_error_log-method_name = lv_current_method.
  ls_error_log-author = lv_author.
  ls_error_log-error_type = '@0A@'.
  ls_error_log-error_line = in_current_line.
  ls_error_log-error_text = ls_item-line_text.
  ls_error_log-description = 'Output Request must be checked before using it'.  "#EC NOTEXT
  APPEND ls_error_log TO lt_error_log.

endmethod.

method FIND_UPPER_RANGE.
  DATA: ls_line LIKE LINE OF lt_working_pool,
        lv_index TYPE i.
  lv_index = 1.
  WHILE lv_index < in_current_line.
     READ TABLE lt_working_pool INTO ls_line INDEX lv_index.
     FIND /SF0A0001/BADI_INTERFACE=>C_DATA IN ls_line-line_text.
     IF sy-subrc = 0.
        upper_line = ls_line-line_num.
        RETURN.
     ENDIF.
     lv_index = lv_index + 1.
  ENDWHILE.
  IF upper_line IS INITIAL.
     MESSAGE e003(/SF0A0001/BADI_INSPE).
  ENDIF.
endmethod.

method PACK_STRING_TABLE.
  DATA: lt_final_table TYPE string_table,
        lv_item TYPE string.

  lt_final_table = c_string_table.
  CLEAR c_string_table.
  LOOP AT lt_final_table INTO lv_item.
    CHECK strlen( lv_item ) > 0.
    APPEND lv_item TO c_string_table.
  ENDLOOP.
endmethod.

method GET_BADI_INFO.
  DATA: lo_enh_impl TYPE REF TO if_enh_tool,
        lo_badi_impl_tool TYPE REF TO cl_enh_tool_badi_impl,
        lx_badi_impl_error TYPE REF TO CX_ENH_BADI_IMPL_NOT_VALID,
        lx_io_error TYPE REF TO CX_ENH_IO_ERROR,
        lv_error TYPE string,
        lt_badi_table TYPE TABLE OF BADIIMPL_ENH,
        ls_badi TYPE BADIIMPL_ENH,
        ex_badi_info TYPE ENH_BADI_IMPL_DATA.

  TRY.
    lo_enh_impl = cl_enh_factory=>get_enhancement(
          enhancement_id         = im_badi_name ).
    CATCH CX_ENH_IO_ERROR into lx_io_error.
       lv_error = lx_io_error->get_text( ).
       lv_error_flag = 1.
       EXIT.
  ENDTRY.

  lo_badi_impl_tool ?= lo_enh_impl.
  " bug reported by Yoyo on 2009/04/08: impl must be used instead of enh name
  SELECT ENHNAME ACTIVE BADI_IMPL FROM BADIIMPL_ENH INTO CORRESPONDING FIELDS OF TABLE lt_badi_table WHERE ENHNAME = im_badi_name.
  ASSERT lines( lt_badi_table ) = 1.
  READ TABLE lt_badi_table INTO ls_badi INDEX 1.
  ASSERT sy-subrc = 0.

  TRY.
     CALL METHOD lo_badi_impl_tool->GET_IMPLEMENTATION
       EXPORTING
          IMPL_NAME         = ls_badi-BADI_IMPL
       RECEIVING
          RE_IMPLEMENTATION = ex_badi_info.

  CATCH CX_ENH_BADI_IMPL_NOT_VALID into lx_badi_impl_error.
    lv_error = lx_badi_impl_error->get_text( ).
    lv_error_flag = 1.
    EXIT.
    "MESSAGE lv_error TYPE 'E'.
  ENDTRY.

  IF ex_badi_info IS INITIAL.
     MESSAGE e004(/SF0A0001/BADI_INSPE) WITH im_badi_name.
  ENDIF.

  lv_badi_impl_name = ex_badi_info-IMPL_CLASS.


endmethod.

method INIT.

  CLEAR:
     lt_working_pool,
     lt_working_source,
     lv_badi_impl_name,
     lv_current_variable,
     lv_error_flag,
     lv_current_method,
     lt_field_symbol_tab,
     lt_reference_tab,
     lt_import_tab,
     lv_author,
     lv_in_method,
     lv_first_error.

     get_badi_info( EXPORTING im_badi_name = in_badi_impl_name ).

     get_author( ).
endmethod.

method FILL_SOURCE_TABLE.
  DATA: ls_source LIKE LINE OF lt_working_source,
        ls_line TYPE TY_LINE.
  CLEAR: lt_working_pool.
  LOOP AT lt_working_source INTO ls_source.
    ls_line-line_num = sy-tabix.
    ls_line-line_text = ls_source.
    TRANSLATE ls_line-line_text TO UPPER CASE.
    APPEND ls_line TO lt_working_pool.
    CLEAR: ls_line.
  ENDLOOP.

endmethod.

method GET_INTERFACE_SOURCE.

 DATA: lv_class TYPE SEOCLSKEY,
       lt_section_source TYPE SEO_SECTION_SOURCE,
       lv_incname TYPE PROGRAM,
       lt_SEOR_IMPLEMENTINGS_R TYPE SEOR_IMPLEMENTINGS_R,
       lt_SEO_REDEFINITIONS TYPE SEO_REDEFINITIONS,
       method_key type SEOCPDKEY.


 lv_class-CLSNAME = lv_badi_impl_name.

* CALL FUNCTION 'SEO_IMPLEMENTG_READ_ALL'
*    EXPORTING
*       CLSKEY = lv_class
*    IMPORTING
*       IMPLEMENTINGS = lt_SEOR_IMPLEMENTINGS_R
*       IMPL_DETAILS = lt_SEO_REDEFINITIONS.
*
* IF lt_SEOR_IMPLEMENTINGS_R IS INITIAL.
*    ASSERT 1 = 0.
*    MESSAGE e000(/SF0A0001/BADI_INSPE) with LV_BADI_IMPL_NAME.
* ENDIF.

 method_key-CLSNAME = lv_badi_impl_name.
 method_key-CPDNAME = 'IF_SPAF_ENHANCE_ASSEMBLE_MSG~ENHANCE_ASSEMBLE_MSG'.
 lv_current_method = 'ENHANCE_ASSEMBLE_MSG'.
 CLEAR lt_working_source.

 " READ SOURCE CODE LOCALLY OR FROM RFC
 IF lv_rfc_mode = 1.
    CALL METHOD GET_SOURCE_CODE_RFC
      EXPORTING
        in_class_name = method_key-CLSNAME
        in_method_name = method_key-CPDNAME.
 ELSE.
   CALL FUNCTION 'SEO_METHOD_GET_SOURCE'
      EXPORTING
        MTDKEY = method_key
      IMPORTING
        SOURCE_expanded = lt_working_source.
 ENDIF.

endmethod.


